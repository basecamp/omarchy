#!/bin/bash
#
# Omarchy AUR Installer with GitHub Mirror Fallback
# Automatically detects AUR availability and falls back to GitHub mirror if needed.
# Usage: omarchy-aur-install <package-name> [package-name...]
#

set -e

# --- Configuration ---
AUR_URL="https://aur.archlinux.org"
AUR_GIT_URL="https://aur.archlinux.org"
GITHUB_MIRROR_URL="https://github.com/archlinux/aur.git"
AUR_CHECK_TIMEOUT=5
AUR_FAILURE_THRESHOLD=3        # Mark AUR as down after this many consecutive failures
AUR_COOLDOWN_MINUTES=20        # Don't retry AUR for this long after marking it down
AUR_STATE_FILE="/tmp/omarchy-aur-state-$(id -u)"  # Per-user state file

# --- Color Output ---
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

print_info() { echo -e "${BLUE}==>${NC} $*"; }
print_success() { echo -e "${GREEN}==>${NC} $*"; }
print_warning() { echo -e "${YELLOW}==>${NC} $*"; }
print_error() { echo -e "${RED}==>${NC} $*"; }
debug_log() { [[ -n "${OMARCHY_AUR_DEBUG:-}" ]] && print_info "$*"; }

# --- Helper Functions ---

# Hardcoded mapping for known split packages
# Format: "package_name:package_base"
# This allows split packages to work even when AUR is down
declare -A KNOWN_SPLIT_PACKAGES=(
  ["yaru-icon-theme"]="yaru"
  ["yaru-gtk-theme"]="yaru"
  ["yaru-gnome-shell-theme"]="yaru"
  ["yaru-sound-theme"]="yaru"
)

# Get PackageBase from AUR RPC API for a given package name
# This is critical for split packages where package name != repository name
# Example: yaru-icon-theme (package) vs yaru (repository/PackageBase)
get_package_base_from_hardcoded() {
  local package_name="$1"

  # Check hardcoded split packages (works even when AUR is down)
  if [[ -n "${KNOWN_SPLIT_PACKAGES[$package_name]:-}" ]]; then
    local hardcoded_base="${KNOWN_SPLIT_PACKAGES[$package_name]}"
    debug_log "Using hardcoded PackageBase for '$package_name': '$hardcoded_base'"
    echo "$hardcoded_base"
    return 0
  fi

  # Not in hardcoded list, return package name
  echo "$package_name"
  return 1
}

# Query AUR RPC to discover PackageBase for split packages
# Only called when clone fails - avoids unnecessary network calls
query_package_base_from_aur() {
  local package_name="$1"

  debug_log "Querying AUR RPC to discover PackageBase for '$package_name'..."

  local rpc_url="https://aur.archlinux.org/rpc/?v=5&type=info&arg=${package_name}"
  local response

  if response=$(curl -s --max-time 3 "$rpc_url" 2>/dev/null); then
    # Extract PackageBase from JSON response
    local package_base=$(echo "$response" | grep -o '"PackageBase":"[^"]*"' | cut -d'"' -f4)

    if [[ -n "$package_base" ]] && [[ "$package_base" != "$package_name" ]]; then
      print_info "Discovered split package: '$package_name' -> PackageBase: '$package_base'"
      echo "$package_base"
      return 0
    fi
  else
    debug_log "Failed to query AUR RPC for '$package_name' (AUR may be down)"
  fi

  # Could not discover different PackageBase
  echo "$package_name"
  return 1
}

# Strip version constraints from package name
strip_version_constraints() {
  local name="$1"
  echo "$name" | sed 's/[<>=].*$//'
}

# Strip version constraints and library references from dependency name
strip_dep_name() {
  local dep="$1"
  echo "$dep" | sed 's/[<>=].*$//' | sed 's/\.so.*$//'
}

# Clone package from GitHub AUR mirror
clone_from_github_mirror() {
  local package_name="$1"
  git clone --depth 1 --single-branch --branch "$package_name" "$GITHUB_MIRROR_URL" "$package_name" 2>/dev/null
}

# Try to clone from AUR, returns 0 on success, 1 on failure
try_clone_from_aur() {
  local package_base="$1"
  local git_url="$2"

  git clone --depth 1 "$git_url/$package_base.git" "$package_base" 2>/dev/null
  return $?
}

# Try to clone from GitHub mirror, returns 0 on success, 1 on failure
try_clone_from_mirror() {
  local package_base="$1"

  clone_from_github_mirror "$package_base"
  return $?
}

# Handle package not found error (check if in official repos)
handle_package_not_found() {
  local package_name="$1"

  if is_official_package "$package_name"; then
    print_error "Package '$package_name' is available in official repositories"
    print_error "Use 'pacman -S $package_name' instead of omarchy-aur-install"
    return 1
  else
    print_error "Package '$package_name' not found in AUR or official repositories"
    print_error "Verify the package name is correct"
    return 1
  fi
}

# --- Pre-flight Checks ---
if [ $# -eq 0 ]; then
  print_error "No package name specified."
  echo "Usage: $0 [--makepkg-flags='FLAGS'] <package-name> [package-name...]"
  echo "Example: $0 --makepkg-flags='--needed -r' package1 package2"
  exit 1
fi

# Parse arguments
EXTRA_MAKEPKG_FLAGS=""
PACKAGES=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --makepkg-flags=*)
      EXTRA_MAKEPKG_FLAGS="${1#*=}"
      shift
      ;;
    --makepkg-flags)
      EXTRA_MAKEPKG_FLAGS="$2"
      shift 2
      ;;
    *)
      PACKAGES+=("$1")
      shift
      ;;
  esac
done

if [ ${#PACKAGES[@]} -eq 0 ]; then
  print_error "No package names specified."
  exit 1
fi

# Check if required tools are installed
for tool in git makepkg curl; do
  if ! command -v "$tool" &>/dev/null; then
    print_error "Required tool '$tool' is not installed."
    exit 1
  fi
done

# --- AUR State Management ---
get_aur_state() {
  if [ -f "$AUR_STATE_FILE" ]; then
    cat "$AUR_STATE_FILE"
  else
    echo "unknown 0 0"  # status failure_count last_check_time
  fi
}

save_aur_state() {
  local status="$1"
  local failure_count="$2"
  local timestamp="$3"
  echo "$status $failure_count $timestamp" > "$AUR_STATE_FILE"
}

is_aur_in_cooldown() {
  local state=($(get_aur_state))
  local status="${state[0]}"
  local last_check="${state[2]}"
  local current_time=$(date +%s)
  local cooldown_seconds=$((AUR_COOLDOWN_MINUTES * 60))

  if [ "$status" = "down" ]; then
    local elapsed=$((current_time - last_check))
    if [ $elapsed -lt $cooldown_seconds ]; then
      local remaining=$(((cooldown_seconds - elapsed) / 60))
      print_warning "AUR marked as down, skipping check (retry in ${remaining}m)"
      return 0  # In cooldown
    fi
  fi
  return 1  # Not in cooldown
}

record_aur_failure() {
  local state=($(get_aur_state))
  local failure_count="${state[1]}"
  local new_count=$((failure_count + 1))
  local timestamp=$(date +%s)

  if [ $new_count -ge $AUR_FAILURE_THRESHOLD ]; then
    print_warning "AUR failed $new_count times, marking as down for ${AUR_COOLDOWN_MINUTES}m"
    save_aur_state "down" "$new_count" "$timestamp"
  else
    save_aur_state "degraded" "$new_count" "$timestamp"
  fi
}

record_aur_success() {
  save_aur_state "up" "0" "$(date +%s)"
}

# --- AUR Availability Check ---
check_aur_available() {
  # TESTING: Simulate AUR being down
  if [[ -n "${OMARCHY_SIMULATE_AUR_DOWN:-}" ]]; then
    print_warning "AUR DOWN SIMULATION ENABLED - Forcing AUR unavailable"
    record_aur_failure
    return 1
  fi

  # Check if in cooldown period
  if is_aur_in_cooldown; then
    return 1
  fi

  print_info "Checking AUR availability..."
  if curl --silent --max-time "$AUR_CHECK_TIMEOUT" --head "$AUR_URL" &>/dev/null; then
    print_success "AUR is available"
    record_aur_success
    return 0
  else
    print_warning "AUR is unreachable (timeout: ${AUR_CHECK_TIMEOUT}s)"
    record_aur_failure
    return 1
  fi
}

# --- Dependency Resolution ---

# Check if a package is available in official repositories
is_official_package() {
  local package="$1"
  # Strip version constraints (>=, =, <, etc.)
  package=$(strip_version_constraints "$package")

  # Check if package can be resolved from sync databases
  # Use -Sp (show package download URL) which will succeed for official packages
  if pacman -Sp "$package" &>/dev/null; then
    debug_log "  DEBUG: '$package' found in official repos (pacman -Sp)"
    return 0
  fi

  debug_log "  DEBUG: '$package' NOT in official repos (AUR package)"
  return 1
}

# Extract dependencies from PKGBUILD
extract_pkgbuild_deps() {
  local pkgbuild_path="$1"

  if [[ ! -f "$pkgbuild_path" ]]; then
    print_error "PKGBUILD not found at: $pkgbuild_path"
    return 1
  fi

  # Source PKGBUILD in a subshell to extract dependency arrays
  (
    # Set up makepkg environment variables that PKGBUILDs may use
    export CARCH="$(uname -m)"
    export CHOST="${CARCH}-unknown-linux-gnu"

    # Debug: Show what CARCH is set to
    [[ -n "${OMARCHY_AUR_DEBUG:-}" ]] && echo "DEBUG:CARCH=$CARCH" >&2
    [[ -n "${OMARCHY_AUR_DEBUG:-}" ]] && echo "DEBUG:CHOST=$CHOST" >&2

    # Temporarily disable errexit in subshell to allow PKGBUILD sourcing
    set +e
    source "$pkgbuild_path" 2>/dev/null
    local source_result=$?
    set -e

    if [ $source_result -ne 0 ]; then
      # PKGBUILD sourcing failed, but continue to extract what we can
      :
    fi

    # Print depends array
    for dep in "${depends[@]:-}"; do
      echo "depend:$dep"
    done

    # Print makedepends array
    for dep in "${makedepends[@]:-}"; do
      echo "makedepend:$dep"
    done

    # Print architecture-specific depends (depends_$CARCH, depends_x86_64, etc.)
    local arch_depends_var="depends_${CARCH}"
    local arch_depends_array="${arch_depends_var}[@]"
    for dep in "${!arch_depends_array:-}"; do
      echo "depend:$dep"
    done

    # Print architecture-specific makedepends (makedepends_$CARCH, makedepends_x86_64, etc.)
    local arch_makedepends_var="makedepends_${CARCH}"
    local arch_makedepends_array="${arch_makedepends_var}[@]"
    for dep in "${!arch_makedepends_array:-}"; do
      echo "makedepend:$dep"
    done

    # Debug: Show counts
    if [[ -n "${OMARCHY_AUR_DEBUG:-}" ]]; then
      local arch_count=0
      eval "arch_count=\${#${arch_makedepends_var}[@]}"
      echo "DEBUG:makedepends_count=${#makedepends[@]}" >&2
      echo "DEBUG:makedepends_${CARCH}_count=${arch_count}" >&2
    fi
  )
}

# Recursively resolve AUR dependencies
# Returns a list of AUR packages needed (in reverse dependency order)
resolve_aur_deps_recursive() {
  local package="$1"
  local resolved_file="$2"  # File to track resolved packages (avoid cycles)
  local deps_file="$3"      # File to accumulate dependencies
  local git_source="$4"     # AUR or GitHub mirror URL
  local use_mirror="$5"     # true/false - whether to use GitHub mirror branch mode

  # Check if already resolved
  if grep -q "^${package}$" "$resolved_file" 2>/dev/null; then
    return 0
  fi

  # Mark as resolved to prevent cycles
  echo "$package" >> "$resolved_file"

  # Get PackageBase for split packages (check hardcoded first)
  local package_base=$(get_package_base_from_hardcoded "$package")

  # Clone package to temporary location to read PKGBUILD
  local temp_dir=$(mktemp -d -p "/tmp" "aur-dep-check-XXXX")
  trap 'rm -rf "$temp_dir"' RETURN

  cd "$temp_dir"

  # Clone from appropriate source (AUR or GitHub mirror)
  local clone_success=false
  if [ "$use_mirror" = "true" ]; then
    # Use GitHub mirror branch mode (use package_base)
    if clone_from_github_mirror "$package_base"; then
      clone_success=true
    fi
  else
    # Use AUR directly (clone using package_base, not package name)
    if git clone --depth 1 "$git_source/$package_base.git" "$package_base" 2>/dev/null; then
      clone_success=true
    fi
  fi

  if [ "$clone_success" = "false" ]; then
    print_warning "Could not fetch PKGBUILD for '$package' - may not exist in AUR"
    return 1
  fi

  if [[ ! -d "$package_base" ]]; then
    print_error "Clone appeared to succeed but directory '$package_base' not found"
    return 1
  fi

  cd "$package_base"

  if [[ ! -f "PKGBUILD" ]]; then
    print_error "No PKGBUILD found in cloned repository for '$package' (base: '$package_base')"
    return 1
  fi

  # Extract dependencies from PKGBUILD
  debug_log "Extracting dependencies from PKGBUILD for '$package'..."
  local deps=$(extract_pkgbuild_deps "PKGBUILD")
  local extract_result=$?

  if [[ -n "${OMARCHY_AUR_DEBUG:-}" ]]; then
    debug_log "Extract result code: $extract_result"
    debug_log "Dependencies for '$package': $(echo "$deps" | wc -l) items"
    if [[ -n "$deps" ]]; then
      echo "$deps" | while read line; do debug_log "  -> $line"; done
    else
      print_warning "No dependencies extracted from PKGBUILD"
    fi
  fi

  if [[ -z "$deps" ]]; then
    # No dependencies found - this is OK, package might have no AUR deps
    debug_log "Adding '$package' to deps file (no dependencies)"
    echo "$package" >> "$deps_file"
    return 0
  fi

  # Process each dependency
  while IFS= read -r dep_line; do
    if [[ -z "$dep_line" ]]; then continue; fi

    local dep_name=$(echo "$dep_line" | cut -d: -f2)
    # Strip version constraints and library references
    dep_name=$(strip_dep_name "$dep_name")

    # Skip empty or library dependencies
    if [[ -z "$dep_name" ]] || [[ "$dep_name" =~ ^lib.*\.so ]]; then
      debug_log "  Skipping library: $dep_name"
      continue
    fi

    # Skip if it's an official package
    if is_official_package "$dep_name"; then
      debug_log "  Skipping official package: $dep_name"
      continue
    fi

    # Recursively resolve this AUR dependency
    debug_log "  Resolving AUR dependency: $dep_name"
    resolve_aur_deps_recursive "$dep_name" "$resolved_file" "$deps_file" "$git_source" "$use_mirror"
  done <<< "$deps"

  # Add this package to the dependency list (after its dependencies)
  echo "$package" >> "$deps_file"

  return 0
}

# --- Package Installation ---
install_package() {
  local package_name="$1"
  local git_url="$2"
  local use_branch="${3:-false}"
  local extra_flags="${4:-}"

  # Check if package is already installed
  if pacman -Q "$package_name" &>/dev/null; then
    print_success "'$package_name' is already installed, skipping"
    return 0
  fi

  print_info "Installing '$package_name'..."

  # Step 1: Get initial PackageBase (check hardcoded, default to package_name)
  local package_base=$(get_package_base_from_hardcoded "$package_name")
  local tried_rpc_discovery=false

  if [[ "$package_base" != "$package_name" ]]; then
    print_info "Using hardcoded mapping: '$package_name' -> '$package_base'"
  fi

  # Create temporary build directory
  local build_dir
  build_dir=$(mktemp -d -p "/tmp" "aur-build-$package_name-XXXX")
  print_info "Using temporary build directory: $build_dir"

  # Ensure cleanup on exit
  trap 'rm -rf "$build_dir"' RETURN

  cd "$build_dir"

  # Step 2: Try cloning with initial package_base
  print_info "Cloning repository for '$package_base'..."
  local clone_success=false
  local state=($(get_aur_state))
  local aur_status="${state[0]}"

  if [ "$use_branch" = "true" ]; then
    # GitHub mirror uses branch-per-package (use package_base for branch name)
    if try_clone_from_mirror "$package_base"; then
      clone_success=true
    fi
  else
    # Check if AUR is marked as down or in cooldown
    if [ "$aur_status" = "down" ] && is_aur_in_cooldown; then
      print_info "AUR is in cooldown, using GitHub mirror directly"
      if try_clone_from_mirror "$package_base"; then
        clone_success=true
      fi
    else
      # Try AUR first (with retries, unless degraded)
      local max_attempts=2
      [ "$aur_status" = "degraded" ] && max_attempts=1

      for attempt in 1 $max_attempts; do
        if try_clone_from_aur "$package_base" "$git_url"; then
          clone_success=true
          record_aur_success  # Reset failure counter
          break
        else
          if [ $attempt -lt $max_attempts ]; then
            print_warning "Clone attempt $attempt failed, retrying..."
            sleep 1
          fi
        fi
      done

      # If AUR clone failed, try GitHub mirror as fallback
      if [ "$clone_success" = "false" ]; then
        record_aur_failure  # Increment failure counter
        print_warning "AUR clone failed, trying GitHub mirror..."
        if try_clone_from_mirror "$package_base"; then
          clone_success=true
          print_success "Successfully cloned from GitHub mirror"
        fi
      fi
    fi
  fi

  # Step 3: If clone failed AND we haven't tried RPC discovery yet, try discovering split package
  if [ "$clone_success" = "false" ] && [ "$tried_rpc_discovery" = "false" ]; then
    print_warning "Clone failed for '$package_base', checking if this is a split package..."

    # Query AUR RPC to discover PackageBase
    local discovered_base=$(query_package_base_from_aur "$package_name")
    tried_rpc_discovery=true

    # If RPC discovered a different PackageBase, retry clone
    if [[ "$discovered_base" != "$package_base" ]]; then
      package_base="$discovered_base"
      print_info "Retrying with discovered PackageBase: '$package_base'..."

      # Retry clone with discovered PackageBase
      if [ "$use_branch" = "true" ]; then
        try_clone_from_mirror "$package_base" && clone_success=true
      elif [ "$aur_status" = "down" ] && is_aur_in_cooldown; then
        try_clone_from_mirror "$package_base" && clone_success=true
      else
        # Try AUR first, then mirror
        if try_clone_from_aur "$package_base" "$git_url"; then
          clone_success=true
          record_aur_success
        elif try_clone_from_mirror "$package_base"; then
          clone_success=true
        fi
      fi
    fi
  fi

  # Step 4: If still failed, give up
  if [ "$clone_success" = "false" ]; then
    handle_package_not_found "$package_name"
    return $?
  fi

  cd "$package_base"

  # Build and install
  print_info "Building and installing '$package_name'..."
  # Add --ignorearch for ARM systems (many AUR packages don't officially support ARM)
  local makepkg_flags=(-si --noconfirm)
  if [[ "$(uname -m)" == "aarch64" ]]; then
    makepkg_flags+=(--ignorearch)
  fi
  # Add any extra flags passed by caller
  if [[ -n "$extra_flags" ]]; then
    # Parse extra flags into array (safe for space-separated tokens)
    read -ra extra_array <<< "$extra_flags"
    makepkg_flags+=("${extra_array[@]}")
  fi
  # Use printf to generate finite number of "1" selections for provider prompts
  # This avoids EPIPE errors that occur with 'yes 1 |' when build processes write verbose output
  printf '1\n%.0s' {1..100} | makepkg "${makepkg_flags[@]}" || {
    print_error "Failed to build/install '$package_name'"
    return 1
  }

  print_success "Successfully installed '$package_name'"
  return 0
}

# --- Main Logic ---
# Determine which git source to use
if check_aur_available; then
  # AUR is available, use standard AUR git
  USE_GITHUB_MIRROR=false
  GIT_SOURCE="$AUR_GIT_URL"
else
  # AUR is down, use GitHub mirror
  print_warning "Falling back to GitHub mirror: $GITHUB_MIRROR_URL"
  USE_GITHUB_MIRROR=true
  GIT_SOURCE="$GITHUB_MIRROR_URL"
fi

# Check if all requested packages are already installed
PACKAGES_TO_INSTALL=()
for package_name in "${PACKAGES[@]}"; do
  if ! pacman -Q "$package_name" &>/dev/null; then
    PACKAGES_TO_INSTALL+=("$package_name")
  else
    print_success "'$package_name' is already installed, skipping"
  fi
done

# If all packages are already installed, exit early
if [ ${#PACKAGES_TO_INSTALL[@]} -eq 0 ]; then
  print_success "All requested packages are already installed"
  exit 0
fi

# ALWAYS resolve AUR dependencies recursively (whether using AUR or GitHub mirror)
# This ensures AUR dependencies of AUR packages are installed automatically
# Official repo dependencies are still handled by makepkg's -s flag
print_info "Resolving AUR dependencies recursively for ${#PACKAGES_TO_INSTALL[@]} packages..."
RESOLVED_FILE=$(mktemp -p "/tmp" "aur-resolved-XXXX")
DEPS_FILE=$(mktemp -p "/tmp" "aur-deps-XXXX")
trap 'rm -f "$RESOLVED_FILE" "$DEPS_FILE"' EXIT

for package_name in "${PACKAGES_TO_INSTALL[@]}"; do
  print_info "Resolving dependencies for '$package_name'..."
  if ! resolve_aur_deps_recursive "$package_name" "$RESOLVED_FILE" "$DEPS_FILE" "$GIT_SOURCE" "$USE_GITHUB_MIRROR"; then
    print_warning "Failed to fully resolve dependencies for '$package_name' - will attempt installation anyway"
  fi
done

# Build list of all AUR dependencies (in order, without duplicates)
ALL_DEPS=()
if [[ -f "$DEPS_FILE" ]]; then
  while IFS= read -r dep; do
    # Skip if already in list (deduplication)
    if [[ ! " ${ALL_DEPS[@]} " =~ " ${dep} " ]]; then
      ALL_DEPS+=("$dep")
    fi
  done < "$DEPS_FILE"
fi

# Remove requested packages from dependency list (we'll install them separately)
DEPS_TO_INSTALL=()
for dep in "${ALL_DEPS[@]}"; do
  if [[ ! " ${PACKAGES_TO_INSTALL[@]} " =~ " ${dep} " ]]; then
    DEPS_TO_INSTALL+=("$dep")
  fi
done

# Install AUR dependencies first
if [[ ${#DEPS_TO_INSTALL[@]} -gt 0 ]]; then
  print_info "Installing ${#DEPS_TO_INSTALL[@]} AUR dependencies: ${DEPS_TO_INSTALL[*]}"
  for dep in "${DEPS_TO_INSTALL[@]}"; do
    print_info "Installing AUR dependency: $dep"
    if ! install_package "$dep" "$GIT_SOURCE" "$USE_GITHUB_MIRROR" "$EXTRA_MAKEPKG_FLAGS"; then
      print_error "Failed to install dependency '$dep' - continuing anyway"
    fi
    echo  # Blank line between packages
  done
else
  print_info "No additional AUR dependencies needed"
fi

# Install requested packages (only those that aren't already installed)
FAILED_PACKAGES=()
for package_name in "${PACKAGES_TO_INSTALL[@]}"; do
  if install_package "$package_name" "$GIT_SOURCE" "$USE_GITHUB_MIRROR" "$EXTRA_MAKEPKG_FLAGS"; then
    :  # Success
  else
    FAILED_PACKAGES+=("$package_name")
  fi
  echo  # Blank line between packages
done

# Summary
if [ ${#FAILED_PACKAGES[@]} -eq 0 ]; then
  print_success "All packages installed successfully"
  exit 0
else
  print_error "Failed to install: ${FAILED_PACKAGES[*]}"
  exit 1
fi
