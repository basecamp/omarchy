#!/usr/bin/env bash
# Interactive TUI setup for trackpad disable-while-typing

set -euo pipefail

# Define logging functions
info() { echo -e "\033[34m[INFO]\033[0m $*"; }
success() { echo -e "\033[32m[SUCCESS]\033[0m $*"; }
warn() { echo -e "\033[33m[WARN]\033[0m $*"; }
error() { echo -e "\033[31m[ERROR]\033[0m $*"; }

# Configuration files
REAL_USER="${SUDO_USER:-$USER}"
REAL_HOME=$(getent passwd "$REAL_USER" | cut -d: -f6)
DWT_SCRIPT="$REAL_HOME/.local/share/omarchy/bin/omarchy-disable-trackpad-while-typing"
SUDOERS_FILE="/etc/sudoers.d/omarchy-trackpad-dwt"
INPUT_CONF="$REAL_HOME/.config/hypr/input.conf"
AUTOSTART_CONF="$REAL_HOME/.config/hypr/autostart.conf"

main() {
  clear
  echo "═══════════════════════════════════"
  echo "Trackpad Disable-While-Typing Setup"
  echo "═══════════════════════════════════"
  echo "" >&2

  # Step 1: Install dependencies
  info "Step 1: Checking dependencies..."
  install_dependencies

  # Step 2: Setup passwordless sudo
  echo "" >&2
  info "Step 2: Setting up passwordless sudo..."
  setup_sudo

  # Step 3: Select keyboard device
  echo "" >&2
  info "Step 3: Select your keyboard device"
  KEYBOARD_DEVICE=$(select_keyboard)

  # Step 4: Select pointer device (trackpad/mouse) to disable while typing
  echo "" >&2
  info "Step 4: Select pointer device to disable while typing"
  TRACKPAD_DEVICE=$(select_trackpad)

  # Step 5: Choose timeout
  echo "" >&2
  info "Step 5: Choose timeout duration"
  TIMEOUT=$(select_timeout)

  # Step 6: Write configuration
  echo "" >&2
  info "Step 6: Writing configuration..."
  write_config "$KEYBOARD_DEVICE" "$TRACKPAD_DEVICE" "$TIMEOUT"

  # Final instructions
  echo "" >&2
  echo    "═════════════════════════"
  success "Setup complete!"
  echo    "═════════════════════════"
  echo "" >&2
  info "The following configuration has been added to your input.conf:"
  echo "" >&2
  echo "  env = OMARCHY_TRACKPAD_DWT_KEYBOARD,$KEYBOARD_DEVICE"
  echo "  env = OMARCHY_TRACKPAD_DWT_TRACKPAD,$TRACKPAD_DEVICE"
  echo "  env = OMARCHY_TRACKPAD_DWT_TIMEOUT,$TIMEOUT"
  echo "" >&2

  # Offer to relaunch Hyprland
  warn "Hyprland needs to be relaunched before the changes will take effect."
  echo "" >&2
  read -p "Relaunch now? [y/N]: " -n 1 -r
  echo "" >&2

  if [[ $REPLY =~ ^[Yy]$ ]]; then
    info "Relaunching Hyprland..."
    # Get the actual user's UID for their session bus
    REAL_UID=$(id -u "$REAL_USER")
    # Run as the real user with their session bus address
    sudo -u "$REAL_USER" DBUS_SESSION_BUS_ADDRESS="unix:path=/run/user/$REAL_UID/bus" bash -c "$REAL_HOME/.local/share/omarchy/bin/omarchy-state clear relaunch-required && uwsm stop"
  else
    info "Skipping relaunch. To relaunch later, use Super+Esc → Relaunch"
  fi

  echo "" >&2
  info "To remove this configuration later:"
  echo "  - Remove the env lines from ~/.config/hypr/input.conf"
  echo "  - Remove the exec-once line from ~/.config/hypr/autostart.conf"
  echo "  - Run: sudo rm /etc/sudoers.d/omarchy-trackpad-dwt"
}

install_dependencies() {
  local deps_needed=false

  if ! command -v evtest &>/dev/null; then
    deps_needed=true
    info "Installing evtest..."
    sudo pacman -S --noconfirm evtest || error "Failed to install evtest"
  fi

  if ! command -v socat &>/dev/null; then
    deps_needed=true
    info "Installing socat..."
    sudo pacman -S --noconfirm socat || error "Failed to install socat"
  fi

  if ! $deps_needed; then
    success "All dependencies are already installed"
  else
    success "Dependencies installed"
  fi
}

setup_sudo() {
  # Check if script exists
  if [ ! -f "$DWT_SCRIPT" ]; then
    error "Script not found: $DWT_SCRIPT"
    info "Please install Omarchy first"
    exit 1
  fi

  # Create sudoers rule with environment variable preservation
  USERNAME="${SUDO_USER:-$USER}"
  RULE="Defaults:$USERNAME env_keep += \"OMARCHY_TRACKPAD_DWT_KEYBOARD OMARCHY_TRACKPAD_DWT_TRACKPAD OMARCHY_TRACKPAD_DWT_TIMEOUT HYPRLAND_INSTANCE_SIGNATURE\"
  $USERNAME ALL=(ALL) NOPASSWD: $DWT_SCRIPT"

  # Create temporary file with proper permissions
  TEMP_FILE=$(mktemp)
  echo "$RULE" > "$TEMP_FILE"

  # Validate the sudoers syntax
  if ! visudo -c -f "$TEMP_FILE" &>/dev/null; then
    error "Invalid sudoers syntax"
    rm -f "$TEMP_FILE"
    exit 1
  fi

  # Install the sudoers file
  if sudo install -m 0440 "$TEMP_FILE" "$SUDOERS_FILE"; then
    success "Passwordless sudo configured"
  else
    error "Failed to install sudoers rule"
    rm -f "$TEMP_FILE"
    exit 1
  fi

  rm -f "$TEMP_FILE"
}

# Generic function to display device selection menu
select_device_from_menu() {
  local -n devices_ref=$1    # Array of device paths (nameref)
  local -n names_ref=$2      # Array of display names (nameref)
  local device_type=$3       # Description (e.g., "keyboard", "pointer device")
  local default_pattern=$4   # Pattern to match for default (e.g., "internal")
  local prompt_msg=$5        # Custom prompt message (optional)

  if [ ${#devices_ref[@]} -eq 0 ]; then
    error "No ${device_type}s found!"
    exit 1
  elif [ ${#devices_ref[@]} -eq 1 ]; then
    success "Found one ${device_type}: ${names_ref[0]}" >&2
    echo "${devices_ref[0]}"
  else
    # Find the default choice based on pattern
    local default_choice=""
    for i in "${!names_ref[@]}"; do
      if echo "${names_ref[$i]}" | grep -q "$default_pattern"; then
        default_choice=$((i + 1))
        break
      fi
    done

    # Show menu
    if [ -n "$prompt_msg" ]; then
      info "$prompt_msg" >&2
    else
      info "Found multiple ${device_type}s. Please select one:" >&2
    fi
    echo "" >&2
    for i in "${!names_ref[@]}"; do
      echo "$((i + 1))) ${names_ref[$i]}" >&2
    done

    # Get user selection
    while true; do
      if [ -n "$default_choice" ]; then
        read -p "Enter number [default: $default_choice]: " choice
        choice=${choice:-$default_choice}
      else
        read -p "Enter number: " choice
      fi

      if [[ "$choice" =~ ^[0-9]+$ ]] && [ "$choice" -ge 1 ] && [ "$choice" -le "${#devices_ref[@]}" ]; then
        echo "${devices_ref[$((choice - 1))]}"
        break
      else
        error "Invalid choice, please enter 1-${#devices_ref[@]}" >&2
      fi
    done
  fi
}

select_keyboard() {
  local keyboards=()
  local names=()

  # Find all keyboard devices
  for input_dev in /sys/class/input/input*; do
    if [ -r "$input_dev/name" ]; then
      device_name=$(cat "$input_dev/name")
      if echo "$device_name" | grep -qi "keyboard\|keyd" && \
         ! echo "$device_name" | grep -qi "mouse\|touchpad\|trackpad"; then
        for event_dev in "$input_dev"/event*; do
          if [ -e "$event_dev" ]; then
            event_path="/dev/input/$(basename "$event_dev")"
            event_name=$(basename "$event_dev")
            # Check if this is an internal (SPI) or external (USB/BT) device
            bus_type="external"
            if udevadm info --query=property "$event_path" 2>/dev/null | grep -q "ID_PATH.*spi"; then
              bus_type="internal"
            fi
            keyboards+=("$event_path")
            names+=("$device_name ($event_name, $bus_type)")
            break
          fi
        done
      fi
    fi
  done

  select_device_from_menu keyboards names "keyboard" "internal" "Found multiple keyboards. Please select one:"
}

select_trackpad() {
  local devices=()
  local names=()

  # Group devices by physical hardware + name to collect all sibling interfaces
  declare -A device_groups
  declare -A device_info

  # Find all pointer devices (trackpad, touchpad, mouse)
  for input_dev in /sys/class/input/input*; do
    if [ -r "$input_dev/name" ]; then
      device_name=$(cat "$input_dev/name")

      for event_dev in "$input_dev"/event*; do
        if [ -e "$event_dev" ]; then
          event_path="/dev/input/$(basename "$event_dev")"
          event_name=$(basename "$event_dev")

          # Check device properties using udevadm
          device_props=$(udevadm info --query=property "$event_path" 2>/dev/null)

          # Only include devices that are mice, touchpads, or trackpads
          if echo "$device_props" | grep -q "ID_INPUT_MOUSE=1\|ID_INPUT_TOUCHPAD=1"; then
            # Get the physical device path (USB device path without interface number)
            # DEVPATH looks like: /devices/.../usb3/3-1/3-1:1.0/0003:05AC:0265.0015/input/input23/event6
            # We want up to the USB device: /devices/.../usb3/3-1
            devpath=$(echo "$device_props" | grep "^DEVPATH=" | cut -d= -f2)

            # Extract physical device path (remove interface and everything after)
            # This removes the :1.0, :1.1 interface numbers and HID device part
            phys_device=$(echo "$devpath" | sed 's|:[0-9]\+\.[0-9]\+/.*||')

            # Create unique key: physical_device + device_name
            # This groups multiple interfaces from same physical device together
            unique_key="${phys_device}::${device_name}"

            # Determine device type
            device_type="pointer"
            if echo "$device_props" | grep -q "ID_INPUT_TOUCHPAD=1"; then
              if echo "$device_name" | grep -qi "trackpad"; then
                device_type="trackpad"
              else
                device_type="touchpad"
              fi
            elif echo "$device_props" | grep -q "ID_INPUT_MOUSE=1"; then
              device_type="mouse"
            fi

            # Check if internal or external
            bus_type="external"
            if echo "$device_props" | grep -q "ID_PATH.*spi"; then
              bus_type="internal"
            fi

            # Collect all event devices for this unique key
            if [ -z "${device_groups[$unique_key]:-}" ]; then
              device_groups[$unique_key]="$event_path"
              device_info[$unique_key]="$device_name|$event_name|$device_type|$bus_type"
            else
              # Append to existing group (colon-separated)
              device_groups[$unique_key]="${device_groups[$unique_key]}:$event_path"
              # Collect event names (will format later)
              current_info="${device_info[$unique_key]}"
              current_events=$(echo "$current_info" | cut -d'|' -f2)
              device_info[$unique_key]="$device_name|${current_events}+${event_name}|$device_type|$bus_type"
            fi
          fi
          break
        fi
      done
    fi
  done

  # Convert to arrays for selection and format display names
  for key in "${!device_groups[@]}"; do
    devices+=("${device_groups[$key]}")
    # Format: "Device Name (event1 + event2, type, bus)"
    info="${device_info[$key]}"
    dev_name=$(echo "$info" | cut -d'|' -f1)
    events=$(echo "$info" | cut -d'|' -f2 | sed 's/+/ + /g')
    dev_type=$(echo "$info" | cut -d'|' -f3)
    bus_type=$(echo "$info" | cut -d'|' -f4)
    names+=("$dev_name ($events, $dev_type, $bus_type)")
  done

  select_device_from_menu devices names "pointer device" "trackpad.*internal" "Found multiple pointer devices. Please select one to disable while typing:"
}

select_timeout() {
  local show_menu=true

  while true; do
    if $show_menu; then
      echo "" >&2
      echo "Select disable-while-typing timeout:" >&2
      echo "" >&2
      echo "1) 0.5 seconds (very short)" >&2
      echo "2) 1.0 seconds (short)" >&2
      echo "3) 1.5 seconds (default)" >&2
      echo "4) 2.0 seconds (long)" >&2
      echo "5) 3.0 seconds (very long)" >&2
      echo "6) Custom" >&2
      echo "" >&2
    fi
    show_menu=true

    read -p "Enter number [default: 3]: " choice
    # Default to 3 if empty
    choice=${choice:-3}

    case $choice in
      1) echo "0.5"; break ;;
      2) echo "1.0"; break ;;
      3) echo "1.5"; break ;;
      4) echo "2.0"; break ;;
      5) echo "3.0"; break ;;
      6)
        echo "" >&2
        read -p "Enter custom timeout in seconds (e.g., 1.75): " custom
        if [[ ! "$custom" =~ ^[0-9]+\.?[0-9]*$ ]]; then
          echo "" >&2
          error "Invalid number" >&2
          # Menu will be re-shown on next loop
        elif (( $(echo "$custom > 10" | awk '{print ($1 > 10)}') )); then
          echo "" >&2
          error "Timeout cannot exceed 10 seconds" >&2
          # Menu will be re-shown on next loop
        else
          echo "$custom"
          break
        fi
        ;;
      *)
        echo "" >&2
        error "Invalid choice" >&2
        # Menu will be re-shown on next loop
        ;;
    esac
  done
}

write_config() {
  local keyboard="$1"
  local trackpad="$2"
  local timeout="$3"

  # Check if config already exists in input.conf
  if grep -q "OMARCHY_TRACKPAD_DWT_KEYBOARD" "$INPUT_CONF" 2>/dev/null; then
    echo "" >&2
    warn "Existing DWT configuration found in input.conf"
    echo "" >&2
    read -p "Replace existing configuration? [Y/n]: " -n 1 -r
    echo "" >&2
    if [[ $REPLY =~ ^[Nn]$ ]]; then
      echo "" >&2
      info "Keeping existing configuration"
      exit 0
    fi

    # Replace existing config lines in-place
    sed -i "s|^env = OMARCHY_TRACKPAD_DWT_KEYBOARD,.*|env = OMARCHY_TRACKPAD_DWT_KEYBOARD,$keyboard|" "$INPUT_CONF"
    sed -i "s|^env = OMARCHY_TRACKPAD_DWT_TRACKPAD,.*|env = OMARCHY_TRACKPAD_DWT_TRACKPAD,$trackpad|" "$INPUT_CONF"
    sed -i "s|^env = OMARCHY_TRACKPAD_DWT_TIMEOUT,.*|env = OMARCHY_TRACKPAD_DWT_TIMEOUT,$timeout|" "$INPUT_CONF"
  else
    # First time setup - add comment and config
    {
      echo ""
      echo "# Trackpad disable-while-typing (configured by omarchy-disable-trackpad-while-typing-tui)"
      echo "env = OMARCHY_TRACKPAD_DWT_KEYBOARD,$keyboard"
      echo "env = OMARCHY_TRACKPAD_DWT_TRACKPAD,$trackpad"
      echo "env = OMARCHY_TRACKPAD_DWT_TIMEOUT,$timeout"
    } >> "$INPUT_CONF"
  fi

  # Handle autostart.conf - only add if it doesn't exist
  local autostart_added=false
  if ! grep -q "omarchy-disable-trackpad-while-typing" "$AUTOSTART_CONF" 2>/dev/null; then
    # First time setup - add comment and exec-once
    {
      echo ""
      echo "# Trackpad disable-while-typing"
      echo "exec-once = sudo $DWT_SCRIPT"
    } >> "$AUTOSTART_CONF"
    autostart_added=true
  fi

  if $autostart_added; then
    success "Configuration written to ~/.config/hypr/input.conf and ~/.config/hypr/autostart.conf"
  else
    success "Configuration written to ~/.config/hypr/input.conf"
  fi
}

# Show usage
if [ "${1:-}" = "--help" ] || [ "${1:-}" = "-h" ]; then
  cat << EOF
Usage: $(basename "$0")

Interactive setup for Trackpad disable-while-typing feature.
This script will guide you through:
  1. Installing required dependencies
  2. Setting up passwordless sudo
  3. Selecting your keyboard and trackpad devices
  4. Choosing a timeout duration
  5. Writing the configuration

The script requires sudo access and will prompt when needed.
EOF
  exit 0
fi

# Check if we need sudo and re-run with it if necessary
if [ "$EUID" -ne 0 ]; then
  info "This script requires sudo access"
  info "Re-running with sudo..."
  exec sudo "$0" "$@"
fi

main "$@"
