#!/bin/bash

# Preserve original script arguments for exec sg kvm (group refresh)
ORIGINAL_SCRIPT_ARGS=("$@")

# Get script directory for accessing resources (icons, etc.)
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"

COMPOSE_FILE="$HOME/.config/windows/docker-compose.yml"
DOCKER_IMAGE="dockurr/windows:latest"
SPICE_DIR="/var/run/omarchy-windows"      # SPICE socket directory (tmpfs, auto-cleaned on reboot)
SPICE_SOCKET_PATH="$SPICE_DIR/spice.sock" # SPICE Unix socket from dockurr/windows container

msg_error() {
  echo "❌  Error: $*"
}

msg_warning() {
  echo "⚠️  Warning: $*"
}

msg_success() {
  echo "✓  $*"
}

msg_info() {
  echo "ℹ️  $*"
}

# Send desktop notification (fails silently if notify-send unavailable)
notify_silent() {
  local title="$1"
  local message="$2"
  local urgency="${3:-normal}"

  if command -v notify-send &>/dev/null; then
    notify-send -u "$urgency" -- "$title" "$message" 2>/dev/null || true
  fi
}

# Check if user is in kvm group and add if needed
# Returns: 0=already in group, 1=added (relogin needed), 2=failed
ensure_user_in_kvm_group() {
  if groups "$USER" | grep -q kvm; then
    return 0
  fi

  if sudo usermod -aG kvm "$USER" 2>/dev/null; then
    return 1
  else
    return 2
  fi
}

# Check if Looking Glass client is fully ready (installed, module loaded, device exists)
is_looking_glass_ready() {
  command -v looking-glass-client &>/dev/null &&
    lsmod | grep -q kvmfr &&
    [[ -e /dev/kvmfr0 ]]
}

# Check if Docker daemon is running
check_docker_running() {
  if docker ps &>/dev/null; then
    return 0
  fi

  msg_error "Docker is not running"
  echo "   Start: sudo systemctl start docker"
  return 1
}

# Get container status by name
get_container_status() {
  local container_name="${1:-omarchy-windows}"
  docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null
}

# Auto-detect RDP scale from Hyprland for HiDPI displays
get_rdp_scale() {
  command -v jq &>/dev/null || return
  local hypr_scale=$(hyprctl monitors -j 2>/dev/null | jq -r '.[] | select (.focused == true) | .scale' 2>/dev/null)
  [[ -z "$hypr_scale" ]] && return

  local scale_percent=$(echo "$hypr_scale" | awk '{print int($1 * 100)}')
  [[ "$scale_percent" =~ ^[0-9]+$ ]] || return

  [[ "$scale_percent" -ge 170 ]] && echo "/scale:180" && return
  [[ "$scale_percent" -ge 130 ]] && echo "/scale:140"
}

# Test if RDP service is ready using X.224 protocol handshake
test_rdp_ready() {
  local -r X224_CR="\x03\x00\x00\x13\x0e\xe0\x00\x00\x00\x00\x00\x01\x00\x08\x00\x03\x00\x00\x00"

  # Send X.224 Connection Request and check for valid RDP response
  printf '%b' "$X224_CR" | timeout 2 nc -w2 127.0.0.1 3389 2>/dev/null |
    head -c2 | od -An -tx1 | tr -d ' \n' | grep -q "^0300$"
}

# Convert file to Windows CRLF line endings
convert_to_crlf() {
  local file="$1"
  [[ ! -f "$file" ]] && {
    msg_error "File not found: $file"
    return 1
  }

  sed -i -e 's/\r$//' -e 's/$/\r/' "$file" || return 1
}

# Connect to Windows VM via RDP
# Parameters:
#   $1 - USERNAME
#   $2 - PASSWORD
#   $3 - BACKGROUND: true (detached) or false (foreground) - default: false
connect_rdp() {
  local USERNAME="$1"
  local PASSWORD="$2"
  local BACKGROUND="${3:-false}"

  # Auto-detect display scale for HiDPI displays
  local RDP_SCALE=$(get_rdp_scale)

  # Check if xfreerdp3 is available
  if ! command -v xfreerdp3 &>/dev/null; then
    echo ""
    msg_warning "xfreerdp3 not found - cannot launch RDP"
    echo "   Install freerdp: omarchy-pkg-add freerdp"
    echo "   Or manually connect via VNC: http://127.0.0.1:8006"
    echo ""
    if [[ "$BACKGROUND" == true ]]; then
      echo "Windows VM is running in background."
      echo "After installing freerdp, connect with: omarchy-windows-vm launch"
      echo ""
    fi
    return 1
  fi

  # Using array to avoid command injection issues
  local RDP_ARGS=(
    /u:"$USERNAME"
    /p:"$PASSWORD"
    /v:127.0.0.1:3389
    -grab-keyboard
    /sound
    /microphone
    /cert:ignore
    /title:"Windows VM - Omarchy"
    /dynamic-resolution
    /gfx:AVC444
    /floatbar:sticky:off,default:visible,show:fullscreen
  )
  [[ -n "$RDP_SCALE" ]] && RDP_ARGS+=("$RDP_SCALE")

  if [[ "$BACKGROUND" == true ]]; then
    # Background mode: Launch detached
    # User can close terminal and keep using Windows
    # Used during/after installation when VM is already running
    setsid uwsm-app -- xfreerdp3 "${RDP_ARGS[@]}" >/dev/null 2>&1 &

    echo ""
    msg_success "RDP window opened in background"
    echo "   You can close this terminal/browser and keep using Windows"
    echo ""
  else
    # Foreground mode: Wait for RDP to close
    # Used by launch command to support --keep-alive logic
    # Script must wait for RDP exit to handle VM lifecycle
    # Note: Keyboard shortcuts are printed by launch_windows() before calling connect_rdp()

    # Launch RDP in background with new session (immune to Ctrl+C)
    # but wait for it to finish (for --keep-alive logic)
    setsid xfreerdp3 "${RDP_ARGS[@]}" >/dev/null 2>&1 &
    local RDP_PID=$!

    # Wait for RDP to close (blocks here, preserves exit code)
    wait $RDP_PID
    local RDP_EXIT=$?

    return $RDP_EXIT
  fi
}

# Check KVM virtualization support
check_kvm_available() {
  if [[ ! -e /dev/kvm ]]; then
    msg_error "KVM virtualization not available!"
    echo ""
    echo "   Please enable virtualization in BIOS or run:"
    echo "     sudo modprobe kvm-intel  # for Intel CPUs"
    echo "     sudo modprobe kvm-amd    # for AMD CPUs"
    return 1
  fi
  return 0
}

check_prerequisites() {
  local DISK_SIZE_GB=${1:-64}
  local REQUIRED_SPACE=$((DISK_SIZE_GB + 10)) # Add 10GB for Windows ISO and overhead

  # Check for KVM support
  if ! check_kvm_available; then
    exit 1
  fi

  # Check disk space
  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')

  if ! [[ "$AVAILABLE_SPACE" =~ ^[0-9]+$ ]] || [[ "$AVAILABLE_SPACE" -eq 0 ]]; then
    msg_error "Failed to calculate available disk space!"
    echo "   Could not determine space on $HOME"
    exit 1
  fi

  if [[ "$AVAILABLE_SPACE" -lt "$REQUIRED_SPACE" ]]; then
    msg_error "Insufficient disk space!"
    echo "   Available: ${AVAILABLE_SPACE}GB"
    echo "   Required: ${REQUIRED_SPACE}GB (${DISK_SIZE_GB}GB disk + 10GB for Windows image)"
    exit 1
  fi
}

check_vm_configured() {
  if [[ ! -f "$COMPOSE_FILE" ]]; then
    msg_error "Windows VM not configured"
    echo "   Run: omarchy-windows-vm install"
    exit 1
  fi
}

install_looking_glass_client() {
  # Returns: 0=success, 1=reboot needed, 2=failed
  # This is a wrapper that calls the dedicated installation script

  # Check if already installed and configured
  if is_looking_glass_ready; then
    msg_success "Looking Glass already installed"
    # Read IVSHMEM size from config
    if [[ -f /etc/modprobe.d/kvmfr.conf ]]; then
      IVSHMEM_SIZE=$(grep -oP 'static_size_mb=\K\d+' /etc/modprobe.d/kvmfr.conf 2>/dev/null || echo "128")
    else
      IVSHMEM_SIZE=128
    fi
    export IVSHMEM_SIZE
    return 0
  fi

  # Check if installation script is available
  if ! command -v omarchy-looking-glass-install &>/dev/null; then
    msg_error "omarchy-looking-glass-install not found"
    echo "   Make sure Omarchy scripts are in PATH"
    return 2
  fi

  # Run the installation script
  echo "Running Looking Glass installation..."
  echo ""

  # Note: Script handles all installation steps interactively
  # It will ask user for resolution choice (1080p/1440p/4K)
  # FORCE_RECONFIGURE=1 allows user to change resolution on each install
  if FORCE_RECONFIGURE=1 omarchy-looking-glass-install; then
    # Installation successful - read IVSHMEM size
    if [[ -f /etc/modprobe.d/kvmfr.conf ]]; then
      IVSHMEM_SIZE=$(grep -oP 'static_size_mb=\K\d+' /etc/modprobe.d/kvmfr.conf 2>/dev/null || echo "128")
    else
      IVSHMEM_SIZE=128
    fi
    export IVSHMEM_SIZE

    # Check if reboot is needed
    if ! is_looking_glass_ready; then
      echo ""
      msg_warning "Looking Glass installed but requires reboot to activate"
      return 1
    fi
    return 0
  else
    # Installation failed
    echo ""
    msg_error "Looking Glass installation failed"
    return 2
  fi
}

create_oem_powershell_script() {
  local OEM_DIR="$1"
  local SCRIPT_VERSION="$2"

  # Step 1: Create PowerShell script with UTF-8 BOM from the start
  printf '\xEF\xBB\xBF' >"$OEM_DIR/install.ps1"

  # Step 2: Append PowerShell script content
  cat >>"$OEM_DIR/install.ps1" <<'EOFPS1'
# Omarchy Windows VM Setup Script
# This script runs automatically after Windows installation completes
# Logs are saved to C:\OEM\install-log.txt for debugging

$LogFile = "C:\OEM\install-log.txt"

# Initialize log file (create if doesn't exist)
try {
    if (-not (Test-Path $LogFile)) {
        New-Item -ItemType File -Path $LogFile -Force | Out-Null
    }
}
catch {
    # If we can't create log file, continue anyway (logs will only go to console)
    Write-Host "WARNING: Could not create log file at $LogFile" -ForegroundColor Yellow
}

function Write-Log {
    param([string]$Message, [string]$Color = "White")
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] $Message"
    Write-Host $Message -ForegroundColor $Color

    try {
        Add-Content -Path $LogFile -Value $logEntry -Encoding UTF8 -ErrorAction Stop
    }
    catch {
        # Silently continue if log write fails
    }
}

Write-Log "=== Omarchy Windows VM Setup Script ===" "Cyan"
Write-Log "Version: SCRIPT_VERSION_PLACEHOLDER" "Gray"
Write-Log "Windows installation complete - running Omarchy setup..." "Green"
Write-Log ""

function Set-InstallationMarker {
    Write-Log "Creating installation completion marker..."

    try {
        Write-Log "Mounting shared folder \\host.lan\Data as Z:..."
        $null = net use Z: \\host.lan\Data /persistent:yes 2>&1

        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $markerContent = "Installation completed at $timestamp"

        if (Test-Path "Z:\") {
            $markerContent | Out-File -FilePath "Z:\installation-complete.txt" -Encoding UTF8
            Write-Log "✓ Marker file created: Z:\installation-complete.txt" "Green"
        }
        else {
            Write-Log "WARNING: Z: drive not available, trying UNC path..." "Yellow"
            $markerContent | Out-File -FilePath "\\host.lan\Data\installation-complete.txt" -Encoding UTF8

            if (Test-Path "\\host.lan\Data\installation-complete.txt") {
                Write-Log "✓ Marker file created via UNC path" "Green"
            }
            else {
                Write-Log "ERROR: Failed to create marker file!" "Red"
            }
        }
    }
    catch {
        Write-Log "ERROR creating marker: $($_.Exception.Message)" "Red"
    }
}

function Install-LookingGlass {
    $installer = "C:\OEM\looking-glass-host-setup.exe"

    if (Test-Path $installer) {
        Write-Log "Installing Looking Glass host..." "Cyan"
        Write-Log "  Installer: $installer" "Gray"
        Write-Log "  Installer size: $((Get-Item $installer).Length) bytes" "Gray"

        try {
            # Log execution context for debugging
            Write-Log "  Current user: $env:USERNAME" "Gray"
            Write-Log "  User domain: $env:USERDOMAIN" "Gray"
            Write-Log "  Running as admin: $(([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))" "Gray"

            # Start installer with timeout to prevent hanging
            # Using only /S for NSIS silent install (not Inno Setup params)
            # IMPORTANT: Do NOT use -NoNewWindow or redirect stdout/stderr during OEM setup
            # as it can cause the installer to hang waiting for console
            Write-Log "  Starting installer (NSIS silent mode with 120s timeout)..." "Gray"
            Write-Log "  Command: $installer /S" "Gray"

            $process = Start-Process -FilePath $installer -ArgumentList "/S" -PassThru -WindowStyle Hidden -ErrorAction Stop

            # Wait max 120 seconds (2 minutes) for installation
            # NSIS installers are typically fast, longer timeout suggests hang
            $timeout = 120
            $waitResult = $process.WaitForExit($timeout * 1000)

            if ($waitResult) {
                $exitCode = $process.ExitCode
                Write-Log "  Installer finished with exit code: $exitCode" "Gray"

                # Check if installation actually succeeded by looking for files
                $lgPaths = @(
                    "C:\Program Files\Looking Glass (host)",
                    "C:\Program Files (x86)\Looking Glass (host)"
                )

                $installed = $false
                foreach ($path in $lgPaths) {
                    if (Test-Path $path) {
                        Write-Log "  Found installation at: $path" "Gray"
                        $installed = $true
                        break
                    }
                }

                if ($installed) {
                    Write-Log "✓ Looking Glass host installation complete!" "Green"

                    # Verify Looking Glass service
                    Start-Sleep -Seconds 1
                    $lgService = Get-Service -Name "looking-glass-host" -ErrorAction SilentlyContinue
                    if ($lgService) {
                        Write-Log "  Service detected: $($lgService.Status)" "Gray"
                        Write-Log "  The service will start after reboot." "Gray"
                    } else {
                        Write-Log "  Service not yet registered (will be available after reboot)" "Gray"
                    }
                }
                elseif ($exitCode -eq 0) {
                    Write-Log "✓ Installer completed (exit code 0)" "Green"
                    Write-Log "  Installation directory not verified (may be custom location)" "Gray"
                }
                else {
                    Write-Log "WARNING: Installation may have failed (exit code: $exitCode)" "Yellow"
                    Write-Log "  Continuing with setup anyway..." "Gray"
                }
            }
            else {
                Write-Log "WARNING: Looking Glass installer did not complete within $timeout seconds" "Yellow"
                Write-Log "  This likely means the installer hung or requires user interaction" "Yellow"
                Write-Log "  Attempting to terminate installer process..." "Gray"

                try {
                    if (-not $process.HasExited) {
                        $process.Kill()
                        $process.WaitForExit(5000)  # Wait 5s for graceful termination
                        Write-Log "  Process terminated" "Gray"
                    }
                }
                catch {
                    Write-Log "  Could not terminate process: $_" "Gray"
                }

                Write-Log "  Continuing with remaining setup tasks..." "Yellow"
            }
        }
        catch {
            Write-Log "ERROR starting Looking Glass installer: $($_.Exception.Message)" "Red"
            Write-Log "  Continuing with remaining setup tasks..." "Yellow"
        }
    }
    else {
        Write-Log "Looking Glass installer not found at: $installer" "Yellow"
        Write-Log "  Expected during installation with GPU passthrough" "Gray"
    }
}

function Install-SpiceGuestTools {
    $installer = "C:\OEM\spice-guest-tools-setup.exe"

    if (Test-Path $installer) {
        Write-Log "Installing SPICE Guest Tools..." "Cyan"
        Write-Log "  Installer: $installer" "Gray"
        Write-Log "  Installer size: $((Get-Item $installer).Length) bytes" "Gray"

        try {
            # Log execution context for debugging
            Write-Log "  Current user: $env:USERNAME" "Gray"
            Write-Log "  User domain: $env:USERDOMAIN" "Gray"
            Write-Log "  Running as admin: $(([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator))" "Gray"

            # Use schtasks to run installer as SYSTEM (prevents driver approval prompts)
            # Windows OEM setup may run as user context, but SPICE drivers require SYSTEM
            $taskName = "OmarchyInstallSPICE"
            Write-Log "  Creating scheduled task to run as SYSTEM (bypass driver prompts)..." "Gray"

            # Create task (force overwrite if exists)
            $taskCmd = "`"$installer`" /S"
            schtasks /Create /TN $taskName /TR $taskCmd /SC ONCE /ST 00:00 /RU SYSTEM /RL HIGHEST /F | Out-Null

            if ($LASTEXITCODE -ne 0) {
                Write-Log "WARNING: Could not create scheduled task (code: $LASTEXITCODE)" "Yellow"
                Write-Log "  Falling back to direct execution..." "Gray"

                # Fallback: run directly
                $process = Start-Process -FilePath $installer -ArgumentList "/S" -PassThru -WindowStyle Hidden -ErrorAction Stop
                $timeout = 120
                $waitResult = $process.WaitForExit($timeout * 1000)

                if (-not $waitResult) {
                    Write-Log "WARNING: Installer timeout, may require user interaction" "Yellow"
                    if (-not $process.HasExited) {
                        $process.Kill()
                        $process.WaitForExit(5000)
                    }
                }

                if ($process.HasExited) {
                    $exitCode = $process.ExitCode
                } else {
                    $exitCode = -1  # Timeout
                }
            }
            else {
                # Run task immediately
                Write-Log "  Executing installer as SYSTEM..." "Gray"
                schtasks /Run /TN $taskName | Out-Null

                # Wait for task to complete (max 120 seconds)
                $timeout = 120
                $elapsed = 0
                $exitCode = 0

                while ($elapsed -lt $timeout) {
                    Start-Sleep -Seconds 2
                    $elapsed += 2

                    # Query task status
                    $taskInfo = schtasks /Query /TN $taskName /FO LIST 2>&1 | Out-String
                    if ($taskInfo -match "Status:\s+(.+)") {
                        $status = $matches[1].Trim()
                        if ($status -ne "Running") {
                            Write-Log "  Task completed (status: $status)" "Gray"
                            break
                        }
                    }
                }

                if ($elapsed -ge $timeout) {
                    Write-Log "WARNING: SPICE installer did not complete within $timeout seconds" "Yellow"
                }

                # Delete task
                schtasks /Delete /TN $taskName /F 2>&1 | Out-Null
            }

            # Check if installation actually succeeded by looking for SPICE agent
            Start-Sleep -Seconds 2  # Give filesystem time to update

            $spicePaths = @(
                "C:\Program Files\SPICE Guest Tools",
                "C:\Program Files (x86)\SPICE Guest Tools",
                "C:\Windows\System32\drivers\vioser.sys"
            )

            $installed = $false
            foreach ($path in $spicePaths) {
                if (Test-Path $path) {
                    Write-Log "  Found SPICE installation at: $path" "Gray"
                    $installed = $true
                    break
                }
            }

            if ($installed) {
                Write-Log "✓ SPICE Guest Tools installation complete!" "Green"
                Write-Log "  Auto-resolution, clipboard, and copy-paste will be available after reboot." "Gray"
            }
            elseif ($exitCode -eq 0) {
                Write-Log "✓ Installer completed (exit code 0)" "Green"
                Write-Log "  Installation directory not verified (may be custom location)" "Gray"
            }
            else {
                Write-Log "WARNING: Installation may have failed (exit code: $exitCode)" "Yellow"
                Write-Log "  Continuing with setup anyway..." "Gray"
            }
        }
        catch {
            Write-Log "ERROR starting SPICE Guest Tools installer: $($_.Exception.Message)" "Red"
            Write-Log "  Continuing with remaining setup tasks..." "Yellow"
        }
    }
    else {
        Write-Log "SPICE Guest Tools installer not found at: $installer" "Yellow"
        Write-Log "  Expected during installation with Looking Glass and GPU passthrough" "Gray"
    }
}

function Set-OmarchyWallpaper {
    $wallpaperSrc = "C:\OEM\wallpaper\omarchy.png"
    $wallpaperDst = "C:\Windows\Web\Wallpaper\Omarchy\omarchy.png"

    if (Test-Path $wallpaperSrc) {
        Write-Log "Setting up Omarchy wallpaper..."

        try {
            $wallpaperDir = Split-Path -Parent $wallpaperDst
            if (-not (Test-Path $wallpaperDir)) {
                New-Item -ItemType Directory -Path $wallpaperDir -Force | Out-Null
            }
            Copy-Item -Path $wallpaperSrc -Destination $wallpaperDst -Force
            Write-Log "  Wallpaper copied to: $wallpaperDst" "Gray"

            Set-ItemProperty -Path 'HKCU:\Control Panel\Desktop' -Name Wallpaper -Value $wallpaperDst -ErrorAction SilentlyContinue

            Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;
public class Wallpaper {
    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    public static extern int SystemParametersInfo(int uAction, int uParam, string lpvParam, int fuWinIni);
}
"@ -ErrorAction SilentlyContinue

            $SPI_SETDESKWALLPAPER = 0x0014
            $SPIF_UPDATEINIFILE = 0x0001
            $SPIF_SENDCHANGE = 0x0002

            [Wallpaper]::SystemParametersInfo($SPI_SETDESKWALLPAPER, 0, $wallpaperDst, $SPIF_UPDATEINIFILE -bor $SPIF_SENDCHANGE) | Out-Null

            Write-Log "✓ Omarchy wallpaper set successfully" "Green"
            Write-Log "  Note: Wallpaper applies immediately (no login required)" "Gray"
        }
        catch {
            Write-Log "ERROR setting wallpaper: $($_.Exception.Message)" "Red"
        }
    }
    else {
        Write-Log "Wallpaper file not found at: $wallpaperSrc" "Yellow"
    }
}

Write-Log ""
Write-Log "Starting OEM setup tasks..."
Write-Log ""

Set-OmarchyWallpaper
Install-LookingGlass
Install-SpiceGuestTools
Set-InstallationMarker

Write-Log ""
Write-Log "=== OEM setup complete! ===" "Green"
Write-Log "Log file saved to: C:\OEM\install-log.txt"

Write-Log ""
Write-Log "Copying log to shared folder..."
try {
    $sharedPath = if (Test-Path "Z:\") { "Z:\" } elseif (Test-Path "\\host.lan\Data") { "\\host.lan\Data\" } else { $null }

    if ($sharedPath) {
        Copy-Item -Path $LogFile -Destination "$sharedPath\install-log.txt" -Force -ErrorAction Stop
        Write-Log "✓ Log copied to: $sharedPath\install-log.txt" "Green"
        Write-Log "  (Available on host: ~/Windows/install-log.txt)" "Gray"
    }
    else {
        Write-Log "WARNING: Shared folder not accessible, log not copied" "Yellow"
    }
}
catch {
    Write-Log "WARNING: Could not copy log to shared folder: $_" "Yellow"
}
EOFPS1

  # Step 3: Replace version placeholder (escape special characters for sed)
  SCRIPT_VERSION_ESCAPED=$(printf '%s\n' "$SCRIPT_VERSION" | sed 's/[&/\]/\\&/g')
  sed -i "s/SCRIPT_VERSION_PLACEHOLDER/$SCRIPT_VERSION_ESCAPED/" "$OEM_DIR/install.ps1"

  # Step 4: Convert to Windows line endings (CRLF)
  convert_to_crlf "$OEM_DIR/install.ps1"
}

create_oem_batch_script() {
  local OEM_DIR="$1"

  cat >"$OEM_DIR/install.bat" <<'EOFBAT'
@echo off
setlocal EnableDelayedExpansion

REM Create marker file to indicate script started
echo OEM setup started at %DATE% %TIME% > C:\OEM\oem-started.txt

REM ======================================
REM Omarchy Windows VM OEM Setup
REM Post-installation customization script
REM ======================================

REM Check for admin privileges
net session >nul 2>&1
if %errorLevel% neq 0 (
    echo ERROR: This script requires administrator privileges!
    echo Please run as administrator.
    pause
    exit /b 1
)

echo ======================================
echo Omarchy Windows VM OEM Setup
echo ======================================
echo.
echo Starting PowerShell setup script...
echo Logs will be saved to C:\OEM\install-log.txt
echo.

REM Log basic information
echo [BATCH] OEM setup started > C:\OEM\batch-log.txt
echo [BATCH] Current directory: %CD% >> C:\OEM\batch-log.txt
echo [BATCH] Script location: %~dp0 >> C:\OEM\batch-log.txt
echo [BATCH] About to execute: powershell.exe -ExecutionPolicy Bypass -NoProfile -File "%~dp0install.ps1" >> C:\OEM\batch-log.txt
echo.

REM Execute PowerShell script and capture exit code
powershell.exe -ExecutionPolicy Bypass -NoProfile -File "%~dp0install.ps1"
set PS_EXIT_CODE=%errorLevel%

echo.
echo ======================================
if %PS_EXIT_CODE% equ 0 (
    echo Setup completed successfully!
    echo Check C:\OEM\install-log.txt for details
) else (
    echo WARNING: Setup finished with errors ^(exit code: %PS_EXIT_CODE%^)
    echo Check C:\OEM\install-log.txt for error details
    echo.
    echo Troubleshooting:
    echo   - Check network connectivity for shared folder
    echo   - Verify file permissions in C:\OEM\
    echo   - Review install-log.txt for specific errors
)
echo ======================================

REM Wait 5 seconds before closing (gives time to read output)
timeout /t 5 /nobreak >nul

exit /b %PS_EXIT_CODE%
EOFBAT

  convert_to_crlf "$OEM_DIR/install.bat"
}

detect_smbios_and_disk_info() {
  # Detect SMBIOS info from host for VM anti-cheat spoofing
  # Sets global variables: SMBIOS_FLAGS, DISK_FLAGS

  SMBIOS_FLAGS=""
  DISK_FLAGS=""

  # Check if dmidecode available (requires root)
  if ! command -v dmidecode &>/dev/null; then
    msg_warning "dmidecode not found - SMBIOS spoofing disabled" >&2
    echo "   Install dmidecode for better anti-cheat compatibility" >&2
    return 0
  fi

  # Helper: Escape SMBIOS values for QEMU (QEMU -smbios doesn't support spaces in values)
  escape_for_qemu() {
    local value="$1"
    value="${value// /_}"  # QEMU -smbios doesn't support spaces
    value="${value//,/,,}" # Escape commas (QEMU convention: double comma)
    echo "$value"
  }

  # SMBIOS Type 0: BIOS Information
  local BIOS_VENDOR="$(sudo dmidecode -s bios-vendor 2>/dev/null | head -1)"
  local BIOS_VERSION="$(sudo dmidecode -s bios-version 2>/dev/null | head -1)"
  local BIOS_DATE="$(sudo dmidecode -s bios-release-date 2>/dev/null | head -1)"

  if [[ -n "$BIOS_VENDOR" ]] && [[ -n "$BIOS_VERSION" ]]; then
    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=0,vendor=$(escape_for_qemu "$BIOS_VENDOR"),version=$(escape_for_qemu "$BIOS_VERSION")"
    [[ -n "$BIOS_DATE" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},date=$(escape_for_qemu "$BIOS_DATE")"
    SMBIOS_FLAGS="${SMBIOS_FLAGS},uefi=on"
  fi

  # SMBIOS Type 1: System Information
  local SYS_MANUFACTURER="$(sudo dmidecode -s system-manufacturer 2>/dev/null | head -1)"
  local SYS_PRODUCT="$(sudo dmidecode -s system-product-name 2>/dev/null | head -1)"
  local SYS_VERSION="$(sudo dmidecode -s system-version 2>/dev/null | head -1)"
  local SYS_SERIAL="$(sudo dmidecode -s system-serial-number 2>/dev/null | head -1)"
  local SYS_UUID="$(sudo dmidecode -s system-uuid 2>/dev/null | head -1)"

  if [[ -n "$SYS_MANUFACTURER" ]] && [[ -n "$SYS_PRODUCT" ]]; then
    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=1,manufacturer=$(escape_for_qemu "$SYS_MANUFACTURER"),product=$(escape_for_qemu "$SYS_PRODUCT")"
    [[ -n "$SYS_VERSION" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},version=$(escape_for_qemu "$SYS_VERSION")"
    [[ -n "$SYS_SERIAL" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$SYS_SERIAL")"
    # UUID must be in format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx (only add if valid)
    if [[ "$SYS_UUID" =~ ^[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}$ ]]; then
      SMBIOS_FLAGS="${SMBIOS_FLAGS},uuid=$SYS_UUID"
    fi
  fi

  # SMBIOS Type 2: Baseboard Information
  # Performance optimization: Commented out (optional for anti-cheat, no performance benefit)
  # local BOARD_MANUFACTURER="$(sudo dmidecode -s baseboard-manufacturer 2>/dev/null | head -1)"
  # local BOARD_PRODUCT="$(sudo dmidecode -s baseboard-product-name 2>/dev/null | head -1)"
  # local BOARD_VERSION="$(sudo dmidecode -s baseboard-version 2>/dev/null | head -1)"
  # local BOARD_SERIAL="$(sudo dmidecode -s baseboard-serial-number 2>/dev/null | head -1)"

  # if [[ -n "$BOARD_MANUFACTURER" ]] && [[ -n "$BOARD_PRODUCT" ]]; then
  #   SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=2,manufacturer=$(escape_for_qemu "$BOARD_MANUFACTURER"),product=$(escape_for_qemu "$BOARD_PRODUCT")"
  #   [[ -n "$BOARD_VERSION" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},version=$(escape_for_qemu "$BOARD_VERSION")"
  #   [[ -n "$BOARD_SERIAL" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$BOARD_SERIAL")"
  # fi

  # SMBIOS Type 3: Chassis Information
  # Performance optimization: Commented out (optional for anti-cheat, no performance benefit)
  # local CHASSIS_MANUFACTURER="$(sudo dmidecode -s chassis-manufacturer 2>/dev/null | head -1)"
  # local CHASSIS_VERSION="$(sudo dmidecode -s chassis-version 2>/dev/null | head -1)"
  # local CHASSIS_SERIAL="$(sudo dmidecode -s chassis-serial-number 2>/dev/null | head -1)"

  # if [[ -n "$CHASSIS_MANUFACTURER" ]]; then
  #   SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=3,manufacturer=$(escape_for_qemu "$CHASSIS_MANUFACTURER")"
  #   [[ -n "$CHASSIS_VERSION" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},version=$(escape_for_qemu "$CHASSIS_VERSION")"
  #   [[ -n "$CHASSIS_SERIAL" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},serial=$(escape_for_qemu "$CHASSIS_SERIAL")"
  # fi

  # SMBIOS Type 4: Processor Information (required by BenchMate for Max Core Frequency)
  local CPU_MANUFACTURER="$(sudo dmidecode -t processor 2>/dev/null | grep -m1 'Manufacturer:' | sed 's/.*Manufacturer: //')"
  local CPU_VERSION="$(sudo dmidecode -t processor 2>/dev/null | grep -m1 'Version:' | sed 's/.*Version: //')"
  local CPU_CURRENT_SPEED="$(sudo dmidecode -t processor 2>/dev/null | grep -m1 'Current Speed:' | grep -oP '\d+' | head -1)"
  local CPU_MAX_SPEED="$(sudo dmidecode -t processor 2>/dev/null | grep -m1 'Max Speed:' | grep -oP '\d+' | head -1)"

  if [[ -n "$CPU_MANUFACTURER" ]] && [[ -n "$CPU_VERSION" ]]; then
    SMBIOS_FLAGS="${SMBIOS_FLAGS} -smbios type=4,manufacturer=$(escape_for_qemu "$CPU_MANUFACTURER"),version=$(escape_for_qemu "$CPU_VERSION")"
    [[ -n "$CPU_CURRENT_SPEED" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},current-speed=${CPU_CURRENT_SPEED}"
    [[ -n "$CPU_MAX_SPEED" ]] && SMBIOS_FLAGS="${SMBIOS_FLAGS},max-speed=${CPU_MAX_SPEED}"
  fi

  # Disk spoofing - detect primary disk
  local DISK_VENDOR="$(lsblk -ndo VENDOR /dev/nvme0n1 2>/dev/null | xargs)"
  local DISK_MODEL="$(lsblk -ndo MODEL /dev/nvme0n1 2>/dev/null | xargs)"
  local DISK_SERIAL="$(lsblk -ndo SERIAL /dev/nvme0n1 2>/dev/null | xargs)"

  # Fallback to /dev/sda if nvme not found
  if [[ -z "$DISK_MODEL" ]]; then
    DISK_VENDOR="$(lsblk -ndo VENDOR /dev/sda 2>/dev/null | xargs)"
    DISK_MODEL="$(lsblk -ndo MODEL /dev/sda 2>/dev/null | xargs)"
    DISK_SERIAL="$(lsblk -ndo SERIAL /dev/sda 2>/dev/null | xargs)"
  fi

  if [[ -n "$DISK_MODEL" ]]; then
    [[ -n "$DISK_VENDOR" ]] && DISK_FLAGS="${DISK_FLAGS} -global scsi-hd.vendor=$(escape_for_qemu "$DISK_VENDOR")"
    DISK_FLAGS="${DISK_FLAGS} -global scsi-hd.product=$(escape_for_qemu "$DISK_MODEL")"
    [[ -n "$DISK_SERIAL" ]] && DISK_FLAGS="${DISK_FLAGS} -global scsi-hd.serial=$(escape_for_qemu "$DISK_SERIAL")"
    # Performance optimization: removed rotation_rate=1 (metadata only, no anti-cheat value)
  fi
}

create_docker_compose_config() {
  local COMPOSE_FILE="$1"
  local SELECTED_RAM="$2"
  local SELECTED_CORES="$3"
  local SELECTED_DISK="$4"
  local USERNAME="$5"
  local PASSWORD="$6"
  local LG_ENABLED="$7"
  local IVSHMEM_SIZE="${8:-128}"
  local GPU_PASSTHROUGH_ENABLED="${9:-false}"
  local GPU_PCI_ADDR="${10:-}"
  local GPU_AUDIO_PCI="${11:-}"
  local GPU_IOMMU_GROUP="${12:-}"

  # Detect SMBIOS and disk info for anti-cheat spoofing
  detect_smbios_and_disk_info

  # Detect CPU info
  local CPU_FLAGS="-cpu host"
  local MACHINE_FLAGS=""

  local CPU_FAMILY="$(grep -m1 'cpu family' /proc/cpuinfo 2>/dev/null | awk '{print $4}')"
  local CPU_MODEL="$(grep -m1 '^model' /proc/cpuinfo 2>/dev/null | awk '{print $3}')"
  local CPU_STEPPING="$(grep -m1 'stepping' /proc/cpuinfo 2>/dev/null | awk '{print $3}')"

  # Validate numeric (some systems report "unknown")
  [[ "$CPU_FAMILY" =~ ^[0-9]+$ ]] || CPU_FAMILY=""
  [[ "$CPU_MODEL" =~ ^[0-9]+$ ]] || CPU_MODEL=""
  [[ "$CPU_STEPPING" =~ ^[0-9]+$ ]] || CPU_STEPPING=""

  if grep -qi 'AuthenticAMD' /proc/cpuinfo 2>/dev/null; then
    # AMD CPU detected
    CPU_FLAGS="-cpu host,kvm=on"
    [[ -n "$CPU_FAMILY" ]] && CPU_FLAGS="${CPU_FLAGS},family=${CPU_FAMILY}"
    [[ -n "$CPU_MODEL" ]] && CPU_FLAGS="${CPU_FLAGS},model=${CPU_MODEL}"
    [[ -n "$CPU_STEPPING" ]] && CPU_FLAGS="${CPU_FLAGS},stepping=${CPU_STEPPING}"
    CPU_FLAGS="${CPU_FLAGS},-hypervisor,hv_vendor_id=AuthenticAMD,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time,+invtsc,+pdpe1gb,+tsc-deadline,migratable=no"

    MACHINE_FLAGS="-machine type=q35,vmport=off,hpet=off,accel=kvm"
  elif grep -qi 'GenuineIntel' /proc/cpuinfo 2>/dev/null; then
    # Intel CPU detected
    CPU_FLAGS="-cpu host,kvm=on"
    [[ -n "$CPU_FAMILY" ]] && CPU_FLAGS="${CPU_FLAGS},family=${CPU_FAMILY}"
    [[ -n "$CPU_MODEL" ]] && CPU_FLAGS="${CPU_FLAGS},model=${CPU_MODEL}"
    [[ -n "$CPU_STEPPING" ]] && CPU_FLAGS="${CPU_FLAGS},stepping=${CPU_STEPPING}"
    CPU_FLAGS="${CPU_FLAGS},-hypervisor,hv_vendor_id=GenuineIntel,hv_relaxed,hv_spinlocks=0x1fff,hv_vapic,hv_time,+invtsc,+pdpe1gb,+tsc-deadline,migratable=no"

    MACHINE_FLAGS="-machine type=q35,vmport=off,hpet=off,accel=kvm"
  fi

  # Auto-detect host timezone
  local HOST_TZ="UTC"
  if [[ -f /etc/timezone ]]; then
    HOST_TZ=$(cat /etc/timezone 2>/dev/null | tr -d '[:space:]')
  elif command -v timedatectl &>/dev/null; then
    HOST_TZ=$(timedatectl show -p Timezone --value 2>/dev/null | tr -d '[:space:]')
  fi
  [[ -z "$HOST_TZ" ]] && HOST_TZ="UTC"

  # Build ARGUMENTS section based on configuration
  local ARGUMENTS_SECTION=""
  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]] && [[ "$LG_ENABLED" == true ]]; then
    # GPU Passthrough + Looking Glass + SPICE
    # vfio-pci passthrough GPU is primary display (console 0)
    # No QXL needed - Looking Glass uses passthrough GPU for display
    ARGUMENTS_SECTION="
      ARGUMENTS: >-"
    [[ -n "$MACHINE_FLAGS" ]] && ARGUMENTS_SECTION+="
        $MACHINE_FLAGS"
    ARGUMENTS_SECTION+="
        $CPU_FLAGS"
    [[ -n "$SMBIOS_FLAGS" ]] && ARGUMENTS_SECTION+="
        $SMBIOS_FLAGS"
    [[ -n "$DISK_FLAGS" ]] && ARGUMENTS_SECTION+="
        $DISK_FLAGS"
    ARGUMENTS_SECTION+="
        -device ivshmem-plain,id=shmem0,memdev=looking-glass
        -object memory-backend-file,id=looking-glass,mem-path=/dev/kvmfr0,size=${IVSHMEM_SIZE}M,share=yes
        -device vfio-pci,host=0000:${GPU_PCI_ADDR}
        -device vfio-pci,host=0000:${GPU_AUDIO_PCI}
        -audiodev spice,id=spice
        -device intel-hda
        -device hda-duplex,audiodev=spice
        -spice unix=on,addr=/tmp/spice/spice.sock,disable-ticketing=on,agent-mouse=off
        -device virtio-serial-pci
        -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0
        -chardev spicevmc,id=spicechannel0,name=vdagent
        -device virtio-mouse-pci
        -device virtio-keyboard-pci
        -global ICH9-LPC.disable_s3=1
        -global ICH9-LPC.disable_s4=1

      USB: \"no\""
  elif [[ "$LG_ENABLED" == true ]]; then
    # Looking Glass only (no GPU passthrough)
    local LG_ARGS="$MACHINE_FLAGS $CPU_FLAGS $SMBIOS_FLAGS $DISK_FLAGS -device ivshmem-plain,id=shmem0,memdev=looking-glass -object memory-backend-file,id=looking-glass,mem-path=/dev/kvmfr0,size=${IVSHMEM_SIZE}M,share=yes"
    LG_ARGS="${LG_ARGS# }" # Trim leading space
    ARGUMENTS_SECTION="
      ARGUMENTS: \"$LG_ARGS\""
  else
    # No GPU passthrough, no Looking Glass - CPU-only VM with anti-cheat flags
    if [[ -n "$MACHINE_FLAGS" ]] || [[ "$CPU_FLAGS" != "-cpu host" ]] || [[ -n "$SMBIOS_FLAGS" ]] || [[ -n "$DISK_FLAGS" ]]; then
      local CPU_ARGS="$MACHINE_FLAGS $CPU_FLAGS $SMBIOS_FLAGS $DISK_FLAGS"
      CPU_ARGS="${CPU_ARGS# }" # Trim leading space
      ARGUMENTS_SECTION="
      ARGUMENTS: \"$CPU_ARGS\""
    fi
  fi

  # Build devices section
  local DEVICES_KVMFR=""
  if [[ "$LG_ENABLED" == true ]]; then
    DEVICES_KVMFR="
      - /dev/kvmfr0:/dev/kvmfr0"
  fi

  local DEVICES_VFIO=""
  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
    DEVICES_VFIO="
      - /dev/vfio/${GPU_IOMMU_GROUP}:/dev/vfio/${GPU_IOMMU_GROUP}
      - /dev/vfio/vfio:/dev/vfio/vfio"
  fi

  # Build ulimits section (needed for VFIO memory locking)
  local ULIMITS_SECTION=""
  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
    ULIMITS_SECTION="

    ulimits:
      memlock:
        soft: -1
        hard: -1"
  fi

  # Build volumes section
  local VOLUMES_SPICE=""
  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]] && [[ "$LG_ENABLED" == true ]]; then
    VOLUMES_SPICE="
      - $SPICE_DIR:/tmp/spice"
  fi

  # Create docker-compose.yml with clean variable substitution
  # If COMPOSE_FILE is "-" or "/dev/stdout", print to stdout instead of file
  if [[ "$COMPOSE_FILE" == "-" ]] || [[ "$COMPOSE_FILE" == "/dev/stdout" ]]; then
    cat <<EOF
services:
  windows:
    image: $DOCKER_IMAGE
    pull_policy: if_not_present
    container_name: omarchy-windows
    environment:
      VERSION: "11"
      RAM_SIZE: "$SELECTED_RAM"
      CPU_CORES: "$SELECTED_CORES"
      DISK_SIZE: "$SELECTED_DISK"
      USERNAME: "$USERNAME"
      PASSWORD: "$PASSWORD"
      TZ: "$HOST_TZ"$ARGUMENTS_SECTION
    devices:
      - /dev/kvm
      - /dev/net/tun$DEVICES_KVMFR$DEVICES_VFIO
    cap_add:
      - NET_ADMIN$ULIMITS_SECTION
    ports:
      - 8006:8006
      - 3389:3389/tcp
      - 3389:3389/udp
    volumes:
      - $HOME/.windows:/storage
      - $HOME/Windows:/shared
      - $HOME/.config/windows/oem:/oem$VOLUMES_SPICE
    restart: "no"
    stop_grace_period: 2m
EOF
  else
    cat >"$COMPOSE_FILE" <<EOF
services:
  windows:
    image: $DOCKER_IMAGE
    pull_policy: if_not_present
    container_name: omarchy-windows
    environment:
      VERSION: "11"
      RAM_SIZE: "$SELECTED_RAM"
      CPU_CORES: "$SELECTED_CORES"
      DISK_SIZE: "$SELECTED_DISK"
      USERNAME: "$USERNAME"
      PASSWORD: "$PASSWORD"
      TZ: "$HOST_TZ"$ARGUMENTS_SECTION
    devices:
      - /dev/kvm
      - /dev/net/tun$DEVICES_KVMFR$DEVICES_VFIO
    cap_add:
      - NET_ADMIN$ULIMITS_SECTION
    ports:
      - 8006:8006
      - 3389:3389/tcp
      - 3389:3389/udp
    volumes:
      - $HOME/.windows:/storage
      - $HOME/Windows:/shared
      - $HOME/.config/windows/oem:/oem$VOLUMES_SPICE
    restart: "no"
    stop_grace_period: 2m
EOF
    chmod 600 "$COMPOSE_FILE"
  fi
}

show_installation_header() {
  local IS_FRESH_INSTALL="$1"

  echo "╭─────────────────────────────────────────────╮"
  if [[ "$IS_FRESH_INSTALL" == "true" ]]; then
    echo "│  Windows Installation Progress              │"
  else
    echo "│  Windows VM Startup                         │"
  fi
  echo "╰─────────────────────────────────────────────╯"
  echo ""

  if [[ "$IS_FRESH_INSTALL" == "true" ]]; then
    echo "Waiting for Windows installation to complete..."
    echo "This may take 10-30 minutes."
    echo ""
  else
    echo "Waiting for Windows VM to boot from existing disk..."
    echo "This may take 1-2 minutes."
    echo ""
  fi
}

draw_progress_bar() {
  local PERCENT="$1"
  local BAR_WIDTH=20

  # Validate and clamp PERCENT to 0-100 range
  [[ ! "$PERCENT" =~ ^[0-9]+$ ]] && PERCENT=0
  [[ "$PERCENT" -gt 100 ]] && PERCENT=100

  # Calculate filled and empty parts
  local FILLED=$((PERCENT * BAR_WIDTH / 100))
  local EMPTY=$((BAR_WIDTH - FILLED))

  # Build progress bar
  local BAR="["
  for ((i = 0; i < FILLED; i++)); do
    BAR+="█"
  done
  for ((i = 0; i < EMPTY; i++)); do
    BAR+="░"
  done
  BAR+="]"

  echo "$BAR"
}

show_disk_usage() {
  local VM_DISK="$1"
  local TIME_PREFIX="$2"

  local DISK_SIZE_MB=0
  if [[ -f "$VM_DISK" ]]; then
    DISK_SIZE_MB=$(du -m "$VM_DISK" | cut -f1 2>/dev/null || echo "0")
    [[ "$DISK_SIZE_MB" =~ ^[0-9]+$ ]] || DISK_SIZE_MB=0
  fi

  # Get max disk size from docker-compose config
  local MAX_DISK_GB=256
  if [[ -f "$COMPOSE_FILE" ]]; then
    MAX_DISK_GB=$(grep -E '^\s*DISK_SIZE:' "$COMPOSE_FILE" | grep -oP '\d+' | head -1)
    [[ "$MAX_DISK_GB" =~ ^[0-9]+$ ]] || MAX_DISK_GB=256
  fi

  # Calculate percentage used
  local MAX_DISK_MB=$((MAX_DISK_GB * 1024))
  local PERCENT_USED=0
  if [[ "$MAX_DISK_MB" -gt 0 ]] && [[ "$DISK_SIZE_MB" -gt 0 ]]; then
    PERCENT_USED=$((DISK_SIZE_MB * 100 / MAX_DISK_MB))
  fi

  # Format with comma separator for MB (using sed, works everywhere)
  local FORMATTED_MB=$(echo "$DISK_SIZE_MB" | sed ':a;s/\B[0-9]\{3\}\>/,&/;ta')

  printf "%s Storage: %s MB / %d GB (%d%% used)\n" "$TIME_PREFIX" "$FORMATTED_MB" "$MAX_DISK_GB" "$PERCENT_USED"
}

handle_installation_marker() {
  local COMPLETION_MARKER="$1"
  local TIME_PREFIX="$2"

  # Remove UTF-8 BOM if present
  local MARKER_CONTENT=$(cat "$COMPLETION_MARKER" 2>/dev/null | LC_ALL=C sed 's/^\xEF\xBB\xBF//' || echo "marker detected")

  echo ""
  printf "%s Installation completion marker detected!\n" "$TIME_PREFIX"
  printf "%s   Windows reports: %s\n" "$TIME_PREFIX" "$MARKER_CONTENT"
  echo ""
  echo "Waiting for RDP service to initialize..."
  echo ""
  printf "%s Giving RDP service time to initialize (10 seconds)...\n" "$TIME_PREFIX"
  sleep 10

  if command -v nc &>/dev/null && nc -z 127.0.0.1 3389 2>/dev/null; then
    printf "%s RDP port is accessible!\n" "$TIME_PREFIX"
  else
    printf "%s RDP port check skipped (netcat not available)\n" "$TIME_PREFIX"
  fi
}

show_installation_summary() {
  local ELAPSED="$1"
  local USERNAME="$2"
  local PASSWORD="$3"
  local LG_ENABLED="${4:-false}"
  local DOWNLOAD_START="$5"
  local EXTRACT_START="$6"
  local OEM_START="$7"
  local BUILD_START="$8"
  local DISK_START="$9"
  local BOOT_START="${10}"
  local WINDOWS_START="${11}"
  local CURRENT="${12}"
  local IS_FRESH_INSTALL="${13:-false}"

  local MINUTES=$((ELAPSED / 60))
  local SECONDS=$((ELAPSED % 60))

  # Note: VM restart removed - Windows installation may not be fully complete
  # User can restart manually if Looking Glass has issues: omarchy-windows-vm stop && omarchy-windows-vm launch --lg

  echo ""
  echo "╭──────────────────────────────────────────────────────────╮"
  echo "│  Installation Complete!                                  │"
  echo "╰──────────────────────────────────────────────────────────╯"
  echo ""
  printf "  Total time: %dm %ds\n" "$MINUTES" "$SECONDS"
  echo ""

  # Calculate individual stage durations (show only non-zero)
  echo "  Stage Timing:"
  if [[ "$DOWNLOAD_START" -gt 0 ]] && [[ "$EXTRACT_START" -gt 0 ]]; then
    local DUR=$((EXTRACT_START - DOWNLOAD_START))
    if [[ "$DUR" -gt 0 ]]; then
      printf "    Download:        %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
    fi
  fi
  if [[ "$EXTRACT_START" -gt 0 ]] && [[ "$OEM_START" -gt 0 ]]; then
    local DUR=$((OEM_START - EXTRACT_START))
    if [[ "$DUR" -gt 0 ]]; then
      printf "    Extract:         %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
    fi
  fi
  if [[ "$BUILD_START" -gt 0 ]] && [[ "$DISK_START" -gt 0 ]]; then
    local DUR=$((DISK_START - BUILD_START))
    if [[ "$DUR" -gt 0 ]]; then
      printf "    Build:           %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
    fi
  fi
  if [[ "$BOOT_START" -gt 0 ]] && [[ "$WINDOWS_START" -gt 0 ]]; then
    local DUR=$((WINDOWS_START - BOOT_START))
    if [[ "$DUR" -gt 0 ]]; then
      printf "    First boot:      %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
    fi
  fi
  if [[ "$WINDOWS_START" -gt 0 ]] && [[ "$CURRENT" -gt 0 ]]; then
    local DUR=$((CURRENT - WINDOWS_START))
    printf "    Windows setup:   %dm %ds\n" "$((DUR / 60))" "$((DUR % 60))"
  fi
  echo ""

  # Show installed components
  echo "  Installed Components:"
  echo "    [OK] Windows 11 Pro"
  if [[ "$LG_ENABLED" == true ]]; then
    echo "    [OK] Looking Glass host service"
  fi
  echo "    [OK] SPICE Guest Tools"
  echo ""

  # Show VM configuration
  echo "  VM Configuration:"
  if [[ -f "$COMPOSE_FILE" ]]; then
    local DISK_GB=$(grep -E '^\s*DISK_SIZE:' "$COMPOSE_FILE" | grep -oP '\d+' | head -1)
    local RAM_GB=$(grep -E '^\s*RAM_SIZE:' "$COMPOSE_FILE" | grep -oP '\d+' | head -1)
    local CPUS=$(grep -E '^\s*CPU_CORES:' "$COMPOSE_FILE" | grep -oP '\d+' | head -1)
    [[ -n "$DISK_GB" ]] && printf "    Disk:   %d GB\n" "$DISK_GB"
    [[ -n "$RAM_GB" ]] && printf "    Memory: %d GB\n" "$RAM_GB"
    [[ -n "$CPUS" ]] && printf "    CPUs:   %d\n" "$CPUS"
  fi
  echo ""

  # Show performance metrics
  echo "  Performance:"
  printf "    Total time:          %dm %ds\n" "$MINUTES" "$SECONDS"
  echo ""

  # Desktop notification
  notify_silent "Windows VM" "Installation complete! (${MINUTES}m ${SECONDS}s)" "normal"
  echo "  Launching connection automatically..."
  echo "  You can start configuring Windows immediately!"
  echo ""
  msg_info "After you close the connection:"
  echo "  • VM will keep running in background"
  echo "  • Reconnect: omarchy-windows-vm launch"
  echo "  • Stop VM: omarchy-windows-vm stop"
  if [[ "$LG_ENABLED" == true ]]; then
    echo ""
    echo "  Looking Glass Configuration (complete setup in Windows):"
    echo ""
    echo "  1. Device Manager → Display adapters"
    echo "     → Right-click 'Red Hat VirtIO GPU DOD controller' → Disable"
    echo ""
    echo "  2. Display Settings"
    echo "     → Set primary display to GPU-connected monitor"
    echo "     → Set correct Display resolution"
    echo "     → May require reconnection if settings not immediately available"
    echo ""
    echo "  3. If you experience issues:"
    echo "     → Restart VM for optimal GPU initialization"
    echo "     → Command: omarchy-windows-vm stop && omarchy-windows-vm launch --lg"
    echo ""
    echo "  Completing steps 1-2 finishes Looking Glass and VM configuration."
  fi
  echo ""
}

connect_looking_glass() {
  local KEEP_ALIVE="${1:-true}"

  # Pre-authenticate sudo for SPICE socket permissions
  # (SPICE socket may need chmod during wait loop)
  sudo -v

  # Auto-fix Looking Glass config if using old SPICE socket path
  LG_CONFIG="$HOME/.config/looking-glass/client.ini"
  if [[ -f "$LG_CONFIG" ]]; then
    if grep -q "host=/tmp/spice/spice.sock" "$LG_CONFIG" 2>/dev/null; then
      echo "  Updating Looking Glass config to new SPICE socket path..."
      sed -i 's|host=/tmp/spice/spice.sock|host=/var/run/omarchy-windows/spice.sock|g' "$LG_CONFIG"
      msg_success "Config updated"
    fi
  fi

  # Validate Looking Glass requirements: client, module, device, permissions
  if ! command -v looking-glass-client &>/dev/null; then
    msg_error "Looking Glass is not installed!"
    echo ""
    echo "Install it with: omarchy-looking-glass-install"
    echo "Or search for 'Install Looking Glass' in the application menu"
    exit 1
  fi

  if ! lsmod | grep -q kvmfr; then
    msg_warning "kvmfr module not loaded, attempting to load..."
    if sudo modprobe kvmfr 2>/dev/null; then
      msg_success "Module loaded successfully"
      sleep 1 # Give udev time to create device
    else
      msg_error "Failed to load kvmfr module"
      echo "   Install: omarchy-looking-glass-install"
      echo "   Then reboot"
      exit 1
    fi
  fi

  if [[ ! -e /dev/kvmfr0 ]]; then
    msg_error "/dev/kvmfr0 not found (module loaded but device missing)"
    echo "   Reinstall: omarchy-looking-glass-install"
    echo "   Then reboot"
    exit 1
  fi

  # Check /dev/kvmfr0 permissions and auto-fix if needed
  USE_SG_KVM=false
  if [[ ! -r /dev/kvmfr0 ]]; then
    # Try to fix permissions silently
    ensure_user_in_kvm_group
    local kvm_status=$?
    case "$kvm_status" in
    1)
      # User was just added to kvm group - use temporary access (silent)
      USE_SG_KVM=true
      ;;
    0)
      # User already in kvm group but session not refreshed - use temporary access (silent)
      USE_SG_KVM=true
      ;;
    2)
      # Failed to add user to kvm group - show error and exit
      echo ""
      msg_error "Cannot access /dev/kvmfr0"
      echo ""
      echo "   Failed to add user to kvm group."
      echo ""
      echo "   Manual fix:"
      echo "   1. sudo usermod -aG kvm \"$USER\""
      echo "   2. Logout and login again (or reboot)"
      echo "   3. Verify: ls -la /dev/kvmfr0"
      echo ""
      exit 1
      ;;
    *)
      # Unexpected return code from ensure_user_in_kvm_group
      echo ""
      msg_error "Cannot access /dev/kvmfr0"
      echo ""
      echo "   Unexpected error (code: $kvm_status)"
      echo "   Please report this issue."
      echo ""
      echo "   Temporary workaround:"
      echo "   1. sudo usermod -aG kvm \"$USER\""
      echo "   2. Logout and login again (or reboot)"
      echo ""
      exit 1
      ;;
    esac
  fi

  # Try to read escape key from client.ini
  local escape_key="Right Ctrl"
  local lg_config="$HOME/.config/looking-glass/client.ini"
  if [[ -f "$lg_config" ]]; then
    local raw_key=$(grep -E '^\s*escapeKey\s*=' "$lg_config" | sed 's/^.*=\s*//' | tr -d ' "')
    case "$raw_key" in
    KEY_SCROLLLOCK | 71) escape_key="Scroll Lock" ;;
    KEY_RIGHTCTRL | 97) escape_key="Right Ctrl" ;;
    KEY_LEFTCTRL | 29) escape_key="Left Ctrl" ;;
    *) escape_key="${raw_key:-Right Ctrl}" ;;
    esac
  fi

  # Wait for QEMU SPICE listener to be ready
  MAX_WAIT=30
  ELAPSED=0
  SPICE_READY=false

  while [[ "$ELAPSED" -lt "$MAX_WAIT" ]]; do
    if [[ -S "$SPICE_SOCKET_PATH" ]]; then
      sudo chmod 666 "$SPICE_SOCKET_PATH" 2>/dev/null || true
    fi

    if timeout 1 env SOCKET_PATH="$SPICE_SOCKET_PATH" python3 -c "import socket, os; s=socket.socket(socket.AF_UNIX); s.connect(os.environ['SOCKET_PATH'])" 2>/dev/null; then
      SPICE_READY=true
      break
    fi
    sleep 2
    ELAPSED=$((ELAPSED + 2))
  done

  if [[ "$SPICE_READY" != true ]]; then
    echo ""
    msg_error "QEMU SPICE listener not ready after ${MAX_WAIT}s"
    echo "   Try RDP instead: omarchy-windows-vm launch"
    echo ""
    exit 1
  fi

  echo ""

  # Build the connection info
  if [[ "$KEEP_ALIVE" == true ]]; then
    LG_LIFECYCLE="VM will keep running after disconnect
To stop: omarchy-windows-vm stop"
  else
    LG_LIFECYCLE="VM will auto-stop when Looking Glass closes"
  fi

  gum style \
    --border normal \
    --padding "1 2" \
    --margin "1" \
    --align center \
    "Connecting to Windows VM via Looking Glass" \
    "" \
    "$LG_LIFECYCLE"

  echo "Waiting 3s for Windows services to fully initialize..."
  sleep 3
  echo ""
  echo "  $escape_key         - Release mouse/keyboard"
  echo "  $escape_key + F     - Toggle fullscreen"
  echo "  $escape_key + Q     - Quit Looking Glass"
  if [[ "$KEEP_ALIVE" == false ]]; then
    echo "  Ctrl+C              - Close terminal (Looking Glass/VM keep running)"
  fi
  echo ""
  echo "  Manual connect: looking-glass-client -F (requires running VM)"
  echo ""

  # Launch Looking Glass client in background (hide logs, immune to Ctrl+C)
  # -F: Fork to background, win:fullScreen=no: windowed mode
  if [[ "$USE_SG_KVM" == true ]]; then
    # User needs temporary kvm group access - run through sg kvm
    sg kvm -c "setsid uwsm-app -- looking-glass-client -F win:fullScreen=no >/dev/null 2>&1" &
    LG_PID=$!
  else
    # Normal launch (user has direct access to /dev/kvmfr0)
    setsid uwsm-app -- looking-glass-client -F win:fullScreen=no >/dev/null 2>&1 &
    LG_PID=$!
  fi

  # Wait for Looking Glass to close (blocks here)
  wait $LG_PID
  LG_EXIT=$?

  # After Looking Glass closes, stop the container unless --keep-alive was specified
  if [[ "$LG_EXIT" -eq 0 ]]; then
    if [[ "$KEEP_ALIVE" == false ]]; then
      echo ""
      echo "Looking Glass session closed. Stopping Windows VM..."
      docker-compose -f "$COMPOSE_FILE" stop
      echo "Windows VM stopped."
      echo ""
      echo "ℹ️  Container is stopped but preserved for fast restart"
      echo "   Quick start: omarchy-windows-vm launch --lg"
      echo "   Full cleanup: omarchy-windows-vm stop (removes container)"
    else
      echo ""
      echo "Looking Glass session closed. Windows VM is still running."
      echo "To stop it: omarchy-windows-vm stop"
    fi
  else
    LG_EXIT_CODE=$?
    echo ""
    msg_error "Looking Glass client exited with error (code: $LG_EXIT_CODE)"
    echo ""
    echo "Possible causes:"
    echo "  • Looking Glass host not installed in Windows VM"
    echo "  • Windows VM not configured with IVSHMEM (reinstall required)"
    echo "  • /dev/kvmfr0 device not accessible"
    echo ""
    echo "Troubleshooting:"
    echo "  1. Check if host is running in Windows: Task Manager → Services → 'Looking Glass'"
    echo "  2. Verify device: ls -l /dev/kvmfr0"
    echo "  3. Check client logs: journalctl -xe | grep looking-glass"
    echo "  4. Try RDP instead: omarchy-windows-vm launch"
    echo ""
    exit 1
  fi
}

launch_after_install() {
  local USERNAME="$1"
  local PASSWORD="$2"
  local USE_LG="${3:-false}"
  local IS_FRESH_INSTALL="${4:-false}"

  # Note: VM restart for Looking Glass is now handled in show_installation_summary()
  # (restart moved before "Installation Complete!" message for better UX)

  echo ""
  if [[ "$USE_LG" == true ]]; then
    echo "Launching Looking Glass..."
    echo "  Toggle fullscreen: Scroll Lock"
    echo ""
  else
    echo "Launching RDP connection..."
    echo "  Toggle fullscreen: Super + F"
    echo ""
  fi

  sleep 3

  if [[ "$USE_LG" == true ]]; then
    # Launch Looking Glass directly (keep-alive implied for post-install)
    connect_looking_glass true
  else
    # Launch RDP with keep-alive
    connect_rdp "$USERNAME" "$PASSWORD" true
  fi
  return $?
}

monitor_installation_progress() {
  local USERNAME="$1"
  local PASSWORD="$2"
  local IS_FRESH_INSTALL="${3:-true}"
  local LG_ENABLED="${4:-false}"
  local VM_DISK="$HOME/.windows/data.img"
  local COMPLETION_MARKER="$HOME/Windows/installation-complete.txt"
  local INSTALL_LOG="$HOME/Windows/install-log.txt"
  local START_TIME=$(date +%s)
  local LAST_DISPLAY_TIME=0
  local LAST_LOG_CHECK=0
  local DISPLAY_INTERVAL=60
  local LOG_CHECK_INTERVAL=5
  local MARKER_CHECK_INTERVAL=5
  local TIMEOUT=3600
  local MARKER_DETECTED=false
  local BOOT_COUNT=0
  local SEEN_STAGES=""
  local LAST_PROGRESS=-1
  local DOWNLOADING=false

  # Stage timing tracking
  local DOWNLOAD_START_TIME=0
  local EXTRACT_START_TIME=0
  local OEM_START_TIME=0
  local BUILD_START_TIME=0
  local DISK_START_TIME=0
  local BOOT_START_TIME=0
  local WINDOWS_START_TIME=0

  rm -f "$COMPLETION_MARKER" "$INSTALL_LOG" 2>/dev/null

  show_installation_header "$IS_FRESH_INSTALL"

  while true; do
    # Calculate elapsed time and format timestamp
    local CURRENT_TIME=$(date +%s)
    local ELAPSED=$((CURRENT_TIME - START_TIME))
    local ELAPSED_MIN=$((ELAPSED / 60))
    local ELAPSED_SEC=$((ELAPSED % 60))
    local TIME_PREFIX=$(printf "[%s | +%dm %02ds]" "$(date +%H:%M:%S)" "$ELAPSED_MIN" "$ELAPSED_SEC")

    # Parse Docker logs for installation stages (only during fresh install)
    if [[ "$IS_FRESH_INSTALL" == "true" ]] && [[ "$((CURRENT_TIME - LAST_LOG_CHECK))" -ge "$LOG_CHECK_INTERVAL" ]]; then
      LAST_LOG_CHECK=$CURRENT_TIME

      # Check if container exists before trying to get logs
      if ! docker inspect omarchy-windows &>/dev/null; then
        # Container doesn't exist yet, skip log parsing this iteration
        sleep "$MARKER_CHECK_INTERVAL"
        continue
      fi

      # Get last 500 lines from Docker logs (covers full download cycle + previous stages)
      local DOCKER_LOGS=$(docker logs --tail 500 omarchy-windows 2>&1)

      # Check for key stages (only show each once)
      if [[ ! "$SEEN_STAGES" =~ "downloading" ]] && echo "$DOCKER_LOGS" | grep -q "Downloading Windows 11"; then
        printf "%s Downloading Windows 11 image...\n" "$TIME_PREFIX"
        SEEN_STAGES="${SEEN_STAGES}downloading "
        DOWNLOADING=true
        DOWNLOAD_START_TIME=$CURRENT_TIME
      fi

      # Show download progress while downloading
      if [[ "$DOWNLOADING" == true ]] && [[ ! "$SEEN_STAGES" =~ "download_complete" ]]; then
        # Extract latest progress % from download lines (format: "65536K .... 1% 97.5M 1m43s")
        local PROGRESS=$(echo "$DOCKER_LOGS" | grep -oP '\s+\K\d+(?=%)' | tail -1)
        if [[ -n "$PROGRESS" ]] && [[ "$PROGRESS" != "$LAST_PROGRESS" ]]; then
          # Extract download speed (e.g., "97.5M" from "1% 97.5M 1m43s")
          local SPEED=$(echo "$DOCKER_LOGS" | grep -oP '\d+%\s+\K[\d.]+[KMG](?=\s)' | tail -1)
          [[ -z "$SPEED" ]] && SPEED="--"

          # Extract ETA (e.g., "1m43s", "43s", "2m", "1h20m")
          local ETA=$(echo "$DOCKER_LOGS" | grep -oP '\d+%\s+[\d.]+[KMG]\s+\K[\dhms]+' | tail -1)
          local ETA_DISPLAY=""
          if [[ -n "$ETA" ]]; then
            ETA_DISPLAY=" ~$ETA remaining"
          fi

          # Draw progress bar
          local PROGRESS_BAR=$(draw_progress_bar "$PROGRESS")

          # Use \r to update same line (carriage return without newline)
          # Clear line with spaces to prevent artifacts from previous longer output
          printf "\r%-100s\r" ""
          printf "%s Downloading: %s %d%% (%s/s)%s" "$TIME_PREFIX" "$PROGRESS_BAR" "$PROGRESS" "$SPEED" "$ETA_DISPLAY"
          LAST_PROGRESS=$PROGRESS
        fi
      fi

      if [[ ! "$SEEN_STAGES" =~ "download_complete" ]] && echo "$DOCKER_LOGS" | grep -q "100%.*=.*s$"; then
        # Print newline to finish progress line, then completion message
        [[ "$DOWNLOADING" == true ]] && echo ""
        printf "%s Download complete [OK]\n" "$TIME_PREFIX"
        SEEN_STAGES="${SEEN_STAGES}download_complete "
        DOWNLOADING=false
      fi

      if [[ ! "$SEEN_STAGES" =~ "extracting" ]] && echo "$DOCKER_LOGS" | grep -q "Extracting Windows"; then
        printf "%s Extracting Windows image...\n" "$TIME_PREFIX"
        SEEN_STAGES="${SEEN_STAGES}extracting "
        EXTRACT_START_TIME=$CURRENT_TIME
      fi

      if [[ ! "$SEEN_STAGES" =~ "oem" ]] && echo "$DOCKER_LOGS" | grep -q "Adding OEM folder"; then
        if [[ "$EXTRACT_START_TIME" -gt 0 ]]; then
          printf "%s Extracting complete [OK]\n" "$TIME_PREFIX"
        fi
        printf "%s Adding OEM setup (Looking Glass + SPICE Guest Tools)...\n" "$TIME_PREFIX"
        SEEN_STAGES="${SEEN_STAGES}oem "
        OEM_START_TIME=$CURRENT_TIME
      fi

      if [[ ! "$SEEN_STAGES" =~ "building" ]] && echo "$DOCKER_LOGS" | grep -q "Building Windows.*image"; then
        if [[ "$OEM_START_TIME" -gt 0 ]]; then
          printf "%s OEM setup complete [OK]\n" "$TIME_PREFIX"
        fi
        printf "%s Building Windows image...\n" "$TIME_PREFIX"
        SEEN_STAGES="${SEEN_STAGES}building "
        BUILD_START_TIME=$CURRENT_TIME
      fi

      if [[ ! "$SEEN_STAGES" =~ "disk_created" ]] && echo "$DOCKER_LOGS" | grep -q "Creating a.*growable disk image"; then
        if [[ "$BUILD_START_TIME" -gt 0 ]]; then
          printf "%s Building complete [OK]\n" "$TIME_PREFIX"
        fi
        printf "%s Creating virtual disk...\n" "$TIME_PREFIX"
        SEEN_STAGES="${SEEN_STAGES}disk_created "
        DISK_START_TIME=$CURRENT_TIME
      fi

      if [[ ! "$SEEN_STAGES" =~ "booting" ]] && echo "$DOCKER_LOGS" | grep -q "Booting Windows using QEMU"; then
        if [[ "$DISK_START_TIME" -gt 0 ]]; then
          printf "%s Disk creation complete [OK]\n" "$TIME_PREFIX"
        fi
        printf "%s Booting Windows...\n" "$TIME_PREFIX"
        SEEN_STAGES="${SEEN_STAGES}booting "
        BOOT_START_TIME=$CURRENT_TIME
      fi

      if [[ ! "$SEEN_STAGES" =~ "started" ]] && echo "$DOCKER_LOGS" | grep -q "Windows started successfully"; then
        if [[ "$BOOT_START_TIME" -gt 0 ]]; then
          printf "%s Boot complete [OK]\n" "$TIME_PREFIX"
        fi
        printf "%s Windows installation started\n" "$TIME_PREFIX"
        SEEN_STAGES="${SEEN_STAGES}started "
        WINDOWS_START_TIME=$CURRENT_TIME
      fi

      # Count Windows Boot Manager occurrences (reboots during setup)
      # Note: Each reboot shows "loading" AND "starting" - count only "loading" to avoid duplicates
      local NEW_BOOT_COUNT
      NEW_BOOT_COUNT=$(echo "$DOCKER_LOGS" | grep -c "BdsDxe: loading Boot.*Windows Boot Manager" 2>/dev/null) || NEW_BOOT_COUNT=0
      # Ensure clean number (remove any whitespace/newlines)
      NEW_BOOT_COUNT=$(echo "$NEW_BOOT_COUNT" | tr -d '[:space:]')
      NEW_BOOT_COUNT=${NEW_BOOT_COUNT:-0}
      if [[ "$NEW_BOOT_COUNT" -gt "$BOOT_COUNT" ]] && [[ "$NEW_BOOT_COUNT" -gt 1 ]]; then
        # Show each reboot increment (in case we missed a check cycle)
        for ((i = $((BOOT_COUNT + 1)); i <= NEW_BOOT_COUNT; i++)); do
          if [[ "$i" -gt 1 ]]; then
            printf "%s Windows setup reboot #%d\n" "$TIME_PREFIX" "$((i - 1))"
          fi
        done
        BOOT_COUNT=$NEW_BOOT_COUNT
      fi
    fi

    # Display storage size every minute (only after disk is created)
    if [[ "$SEEN_STAGES" =~ "disk_created" ]]; then
      if [[ "$((CURRENT_TIME - LAST_DISPLAY_TIME))" -ge "$DISPLAY_INTERVAL" ]] || [[ "$LAST_DISPLAY_TIME" -eq 0 ]]; then
        LAST_DISPLAY_TIME=$CURRENT_TIME
        show_disk_usage "$VM_DISK" "$TIME_PREFIX"
      fi
    fi

    # Check for OEM completion marker (created by Windows after installation)
    if [[ "$MARKER_DETECTED" == false ]]; then
      if [[ -f "$COMPLETION_MARKER" ]]; then
        MARKER_DETECTED=true
        handle_installation_marker "$COMPLETION_MARKER" "$TIME_PREFIX"
      else
        sleep $MARKER_CHECK_INTERVAL
        continue
      fi
    fi

    if [[ "$MARKER_DETECTED" == true ]]; then
      show_installation_summary "$ELAPSED" "$USERNAME" "$PASSWORD" "$LG_ENABLED" \
        "$DOWNLOAD_START_TIME" "$EXTRACT_START_TIME" "$OEM_START_TIME" \
        "$BUILD_START_TIME" "$DISK_START_TIME" "$BOOT_START_TIME" \
        "$WINDOWS_START_TIME" "$CURRENT_TIME" "$IS_FRESH_INSTALL"
      launch_after_install "$USERNAME" "$PASSWORD" "$LG_ENABLED" "$IS_FRESH_INSTALL"
      break
    fi

    if [[ "$ELAPSED" -ge "$TIMEOUT" ]]; then
      local MINUTES=$((ELAPSED / 60))
      local SECONDS=$((ELAPSED % 60))

      echo ""
      msg_warning "Installation monitoring timeout (60 minutes)"
      echo ""
      printf "    Time elapsed: %d minutes %d seconds\n" "$MINUTES" "$SECONDS"
      echo ""
      echo "VM is still running and may be installing."
      echo ""
      echo "To check progress or connect:"
      echo "  • VNC Monitor: http://127.0.0.1:8006"
      echo "  • RDP: omarchy-windows-vm launch"
      echo "  • Logs: docker logs -f omarchy-windows"
      echo ""
      echo "If installation completed, RDP will work."
      echo "If still installing, use VNC to monitor."
      echo ""
      break
    fi
  done
}

# Build dockurr/windows:latest with SPICE support
# SPICE module (qemu-system-modules-spice) was rejected from upstream
# See: https://github.com/dockur/windows/pull/1567
build_dockurr_windows_with_spice() {
  local build_dir="/tmp/dockurr-windows-spice-$$"

  # Cleanup on exit (success, failure, or Ctrl+C)
  trap "rm -rf '$build_dir' 2>/dev/null || true" EXIT INT TERM

  echo ""
  msg_info "Building dockurr/windows:latest with SPICE support..."
  echo "This may take 5-10 minutes..."
  echo ""

  # Clone dockur/windows repository
  if ! git clone --quiet --depth 1 https://github.com/dockur/windows.git "$build_dir" 2>/dev/null; then
    msg_error "Failed to clone dockur/windows repository"
    echo "   Check internet connection or try again later"
    return 1
  fi

  cd "$build_dir" || {
    msg_error "Failed to enter build directory"
    return 1
  }

  msg_success "Repository cloned"
  msg_info "Modifying Dockerfile to add SPICE support..."

  # Check if SPICE already present (prevent duplicate additions)
  if grep -q 'qemu-system-modules-spice' Dockerfile; then
    msg_success "Dockerfile already has SPICE support (no modification needed)"
  else
    # Modify Dockerfile: add qemu-system-modules-spice after libarchive-tools
    # Change: libarchive-tools && \
    #    to:  libarchive-tools \
    #         qemu-system-modules-spice && \
    if ! sed -i 's/libarchive-tools && \\/libarchive-tools \\\n        qemu-system-modules-spice \&\& \\/' Dockerfile; then
      msg_error "Failed to modify Dockerfile"
      msg_error "Dockerfile format may have changed - sed pattern didn't match"
      echo "   Expected line: libarchive-tools && \\"
      echo "   Please report this issue with your dockur/windows version"
      return 1
    fi

    # Verify modification succeeded
    if ! grep -q 'qemu-system-modules-spice' Dockerfile; then
      msg_error "Dockerfile modification verification failed"
      echo "   sed completed but SPICE not found in result"
      echo "   This may indicate Dockerfile format changed"
      return 1
    fi

    msg_success "Dockerfile modified (qemu-system-modules-spice added)"
  fi

  echo ""
  msg_info "Building Docker image..."
  echo "(This step downloads base image and installs packages)"
  echo ""

  # Build image (show output for transparency)
  if ! docker build -t dockurr/windows:latest .; then
    echo ""
    msg_error "Docker build failed"
    echo "   Check Docker daemon status: systemctl status docker"
    echo "   Check disk space: df -h"
    return 1
  fi

  echo ""
  msg_success "dockurr/windows:latest built successfully with SPICE support"
  echo ""

  # trap EXIT will cleanup $build_dir automatically
  return 0
}

# Ensure dockurr/windows:latest has SPICE support
# Checks if image exists and has qemu-system-modules-spice
# Rebuilds if missing or lacks SPICE
ensure_dockurr_windows_with_spice() {
  msg_info "Checking dockurr/windows:latest Docker image..."
  echo ""

  # Check Docker daemon is running
  if ! docker info &>/dev/null; then
    msg_error "Docker daemon is not running"
    echo "   Start Docker: sudo systemctl start docker"
    echo "   Enable on boot: sudo systemctl enable docker"
    return 1
  fi

  # Check if image exists locally
  if docker image inspect dockurr/windows:latest &>/dev/null; then
    msg_success "Image exists locally"
    msg_info "Checking for SPICE support..."

    # Check image history for qemu-system-modules-spice (faster than docker run)
    # Image built by our script will have SPICE in layer commands
    if docker history --no-trunc dockurr/windows:latest 2>/dev/null | grep -q 'qemu-system-modules-spice'; then
      msg_success "SPICE support detected in image layers"
      echo ""
      return 0
    else
      msg_warning "Image lacks SPICE support in build history"
      msg_info "Removing old image and rebuilding with SPICE..."
      echo ""

      # Remove old image
      docker rmi dockurr/windows:latest 2>/dev/null || true
    fi
  else
    msg_warning "Image not found locally"
    msg_info "Building with SPICE support..."
    echo ""
  fi

  # Build image with SPICE
  if ! build_dockurr_windows_with_spice; then
    echo ""
    msg_error "Failed to build dockurr/windows:latest with SPICE support"
    echo ""
    echo "   Looking Glass requires SPICE for input handling"
    echo "   Build failed - cannot continue with Looking Glass enabled"
    echo ""
    return 1
  fi

  return 0
}

install_windows() {
  # Set up trap to handle Ctrl+C
  trap "echo ''; echo 'Installation cancelled by user'; exit 1" INT

  # Request sudo access upfront (avoids password prompt during installation)
  if ! sudo -v 2>/dev/null; then
    msg_error "sudo access required for installation"
    exit 1
  fi

  # Handle existing installation - fresh or quick reinstall
  if [[ -f "$COMPOSE_FILE" ]] || [[ -d "$HOME/.windows" ]]; then
    # Read previous configuration before showing reinstall choice
    PREVIOUS_RAM=""
    PREVIOUS_CPU=""
    PREVIOUS_DISK=""
    PREVIOUS_USERNAME=""
    PREVIOUS_PASSWORD=""
    PREVIOUS_LG_ENABLED=false
    PREVIOUS_GPU_ENABLED=false

    if [[ -f "$COMPOSE_FILE" ]]; then
      # Extract values from docker-compose.yml
      PREVIOUS_RAM=$(grep '^\s*RAM_SIZE:' "$COMPOSE_FILE" | sed 's/.*RAM_SIZE: "\(.*\)".*/\1/' | tr -d '"')
      PREVIOUS_CPU=$(grep '^\s*CPU_CORES:' "$COMPOSE_FILE" | sed 's/.*CPU_CORES: "\(.*\)".*/\1/' | tr -d '"')
      PREVIOUS_DISK=$(grep '^\s*DISK_SIZE:' "$COMPOSE_FILE" | sed 's/.*DISK_SIZE: "\(.*\)".*/\1/' | tr -d '"')
      PREVIOUS_USERNAME=$(grep '^\s*USERNAME:' "$COMPOSE_FILE" | sed 's/.*USERNAME: "\(.*\)".*/\1/' | tr -d '"')
      PREVIOUS_PASSWORD=$(grep '^\s*PASSWORD:' "$COMPOSE_FILE" | sed 's/.*PASSWORD: "\(.*\)".*/\1/' | tr -d '"')

      # Check Looking Glass (ivshmem-plain in ARGUMENTS)
      if grep -q 'ivshmem-plain' "$COMPOSE_FILE"; then
        PREVIOUS_LG_ENABLED=true
      fi

      # Check GPU passthrough (vfio-pci in ARGUMENTS)
      if grep -q 'vfio-pci' "$COMPOSE_FILE"; then
        PREVIOUS_GPU_ENABLED=true
      fi
    fi

    msg_warning "Previous Windows VM installation detected"
    echo ""
    echo "Found:"
    [[ -f "$COMPOSE_FILE" ]] && echo "  • Configuration: $COMPOSE_FILE"
    [[ -d "$HOME/.windows" ]] && echo "  • VM disk: $HOME/.windows/"

    # Show previous configuration if available
    if [[ -n "$PREVIOUS_RAM" ]]; then
      echo ""
      echo "Previous configuration:"
      echo "  RAM:              $PREVIOUS_RAM"
      echo "  CPU:              $PREVIOUS_CPU cores"
      echo "  Disk:             $PREVIOUS_DISK"
      echo "  Username:         $PREVIOUS_USERNAME"
      echo "  GPU Passthrough:  $([[ "$PREVIOUS_GPU_ENABLED" == true ]] && echo "Enabled" || echo "Disabled")"
      echo "  Looking Glass:    $([[ "$PREVIOUS_LG_ENABLED" == true ]] && echo "Enabled" || echo "Disabled")"
    fi

    echo ""
    echo "What would you like to do?"
    echo ""

    REINSTALL_CHOICE=$(gum choose --selected="Quick reinstall (keep VM data, update config)" \
      "Quick reinstall (keep VM data, update config)" \
      "Fresh install (delete all data and reinstall)")

    # Check if user cancelled (Ctrl+C returns empty string)
    if [[ -z "$REINSTALL_CHOICE" ]]; then
      echo ""
      echo "Installation cancelled by user"
      exit 1
    fi

    if [[ "$REINSTALL_CHOICE" == "Fresh install"* ]]; then
      echo ""
      echo "Fresh installation: Removing all previous data..."
      echo ""
      echo "This will DELETE:"
      msg_error "VM disk and Windows OS ($HOME/.windows/)"
      msg_error "Configuration files"
      echo ""
      echo "This will KEEP:"
      echo "  ✅ Shared files ($HOME/Windows/) - your data"
      echo ""

      docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true
      rm -f "$COMPOSE_FILE"
      rm -rf "$HOME/.config/windows"

      if [[ -d "$HOME/.windows" ]]; then
        echo "  • Removing VM disk..."
        sudo rm -rf "$HOME/.windows"
      fi

      [[ -d "$HOME/.config/windows/oem" ]] && rm -rf "$HOME/.config/windows/oem" 2>/dev/null
      rm -f "$HOME/Windows/installation-complete.txt" 2>/dev/null
      rm -f "$HOME/.local/share/applications/windows-vm.desktop" "$HOME/.local/share/applications/windows-looking-glass.desktop"

      # Update desktop database after removing old icons
      if command -v update-desktop-database &>/dev/null; then
        update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
      fi

      echo ""
      msg_success "Previous installation completely removed"
      echo ""

      # Clear previous values to use intelligent defaults for fresh install
      PREVIOUS_RAM=""
      PREVIOUS_CPU=""
      PREVIOUS_DISK=""
      PREVIOUS_USERNAME=""
      PREVIOUS_PASSWORD=""
    else
      echo ""
      echo "Quick reinstall: Keeping VM disk, updating configuration..."
      echo ""

      # Stop VM but keep configuration until user confirms new settings
      docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true

      msg_success "VM stopped, configuration preserved (will update after confirmation)"
      echo ""
      echo "ℹ️  Quick reinstall only updates docker-compose configuration"
      echo "   Windows installation and all your files remain unchanged"
      echo "   VM will boot to existing Windows system with new config"
      echo ""

      # Skip OEM auto-run since Windows is already installed
      # Mark for later cleanup (after user confirms configuration)
      SKIP_OEM_AUTORUN=true
      QUICK_REINSTALL_CLEANUP=true
    fi
  fi

  check_prerequisites

  omarchy-pkg-add freerdp openbsd-netcat dmidecode

  mkdir -p "$HOME/.windows"
  mkdir -p "$HOME/.config/windows"

  # Get system resources
  TOTAL_RAM=$(free -h | awk 'NR==2 {print $2}')
  TOTAL_RAM_GB=$(awk 'NR==1 {printf "%d", $2/1024/1024}' /proc/meminfo)
  TOTAL_CORES=$(nproc)

  # Validate RAM detection (must be positive number)
  if ! [[ "$TOTAL_RAM_GB" =~ ^[0-9]+$ ]] || [[ "$TOTAL_RAM_GB" -eq 0 ]]; then
    msg_warning "Could not detect total RAM, using safe default (8GB)"
    TOTAL_RAM_GB=8
    TOTAL_RAM="8G"
  fi

  # Validate TOTAL_RAM display value (Bug #30 fix)
  if [[ -z "$TOTAL_RAM" ]]; then
    TOTAL_RAM="${TOTAL_RAM_GB}G"
  fi

  echo ""
  echo "System Resources Detected:"
  echo "  Total RAM: $TOTAL_RAM"
  echo "  Total CPU Cores: $TOTAL_CORES"
  echo ""

  RAM_OPTIONS=""
  for size in 2 4 8 16 32 64; do
    if [[ "$size" -le "$TOTAL_RAM_GB" ]]; then
      RAM_OPTIONS="$RAM_OPTIONS ${size}G"
    fi
  done

  # Use previous RAM if available, otherwise calculate intelligent default (half of total, choose smaller)
  if [[ -n "$PREVIOUS_RAM" ]]; then
    DEFAULT_RAM="$PREVIOUS_RAM"
  else
    # Calculate half of total RAM, find largest value from options that is smaller than half
    HALF_RAM=$((TOTAL_RAM_GB / 2))
    DEFAULT_RAM="4G"            # fallback
    for size in 32 16 8 4 2; do # reversed order (largest to smallest)
      if [[ "$size" -lt "$HALF_RAM" ]] && [[ "$size" -le "$TOTAL_RAM_GB" ]]; then
        DEFAULT_RAM="${size}G"
        break
      fi
    done
  fi
  SELECTED_RAM=$(echo "$RAM_OPTIONS" | tr ' ' '\n' | gum choose --selected="$DEFAULT_RAM" --header="How much RAM would you like to allocate to Windows VM?")

  # Check if user cancelled
  if [[ -z "$SELECTED_RAM" ]]; then
    echo "Installation cancelled by user"
    exit 1
  fi

  # Use previous CPU cores if available, otherwise calculate intelligent default (quarter of total)
  if [[ -n "$PREVIOUS_CPU" ]]; then
    DEFAULT_CORES="$PREVIOUS_CPU"
  else
    # Calculate quarter of total cores (conservative: leave more for host)
    DEFAULT_CORES=$((TOTAL_CORES / 4))
    [[ "$DEFAULT_CORES" -lt 1 ]] && DEFAULT_CORES=1
  fi
  SELECTED_CORES=$(gum input --placeholder="Number of CPU cores (1-$TOTAL_CORES)" --value="$DEFAULT_CORES" --header="How many CPU cores would you like to allocate to Windows VM?" --char-limit=2)

  # Check if user cancelled (Ctrl+C in gum input returns empty string)
  if [[ -z "$SELECTED_CORES" ]]; then
    echo "Installation cancelled by user"
    exit 1
  fi

  if ! [[ "$SELECTED_CORES" =~ ^[0-9]+$ ]] || [[ "$SELECTED_CORES" -lt 1 ]] || [[ "$SELECTED_CORES" -gt "$TOTAL_CORES" ]]; then
    echo "Invalid input. Using default: 2 cores"
    SELECTED_CORES=2
  fi

  AVAILABLE_SPACE=$(df "$HOME" | awk 'NR==2 {print int($4/1024/1024)}')
  MAX_DISK_GB=$((AVAILABLE_SPACE - 10)) # Leave 10GB for Windows image

  # Check if we have enough space for minimum
  if [[ "$MAX_DISK_GB" -lt 32 ]]; then
    msg_error "Insufficient disk space for Windows VM!"
    echo "   Available: ${AVAILABLE_SPACE}GB"
    echo "   Minimum required: 42GB (32GB disk + 10GB for Windows image)"
    exit 1
  fi

  DISK_OPTIONS=""
  for size in 32 64 128 256 512 1024; do
    if [[ "$size" -le "$MAX_DISK_GB" ]]; then
      DISK_OPTIONS="$DISK_OPTIONS ${size}G"
    fi
  done

  # Use previous disk if available, otherwise calculate intelligent default (half of max, choose smaller, cap at 256GB)
  if [[ -n "$PREVIOUS_DISK" ]] && echo "$DISK_OPTIONS" | grep -q "$PREVIOUS_DISK"; then
    DEFAULT_DISK="$PREVIOUS_DISK"
  else
    # Calculate half of max disk space, find largest value smaller than half (max suggestion: 256GB)
    HALF_DISK=$((MAX_DISK_GB / 2))
    DEFAULT_DISK="32G"            # fallback
    for size in 256 128 64 32; do # removed 512, max suggestion is 256GB
      if [[ "$size" -lt "$HALF_DISK" ]] && [[ "$size" -le "$MAX_DISK_GB" ]]; then
        DEFAULT_DISK="${size}G"
        break
      fi
    done
  fi

  SELECTED_DISK=$(echo "$DISK_OPTIONS" | tr ' ' '\n' | gum choose --selected="$DEFAULT_DISK" --header="How much disk space would you like to give Windows VM? (64GB+ recommended)")

  # Check if user cancelled
  if [[ -z "$SELECTED_DISK" ]]; then
    echo "Installation cancelled by user"
    exit 1
  fi

  # Extract just the number for prerequisite check
  DISK_SIZE_NUM=$(echo "$SELECTED_DISK" | sed 's/G//')

  # Re-check prerequisites with selected disk size
  check_prerequisites "$DISK_SIZE_NUM"

  # Prompt for username and password
  # Use previous username if available, otherwise show default
  if [[ -n "$PREVIOUS_USERNAME" ]]; then
    USERNAME=$(gum input --placeholder="Username (Press enter to use previous: $PREVIOUS_USERNAME)" --value="$PREVIOUS_USERNAME" --header="Enter Windows username:")
    if [[ -z "$USERNAME" ]]; then
      USERNAME="$PREVIOUS_USERNAME"
    fi
  else
    USERNAME=$(gum input --placeholder="Username (Press enter to use default: docker)" --header="Enter Windows username:")
    if [[ -z "$USERNAME" ]]; then
      USERNAME="docker"
    fi
  fi

  # Validate username (no quotes or special YAML chars)
  if [[ "$USERNAME" =~ [\"\'\`\$\\] ]]; then
    msg_error "Username cannot contain quotes, backticks, dollar signs, or backslashes"
    echo "   These characters would break the configuration file"
    exit 1
  fi

  # Password prompt - different logic for Quick reinstall vs Fresh install
  if [[ -n "$PREVIOUS_USERNAME" ]]; then
    # Quick reinstall - ask if user wants to change password
    echo ""
    if gum confirm --default=false "Change Windows password in docker-compose configuration?"; then
      echo ""
      msg_warning "Important: This only updates docker-compose.yml configuration"
      echo "   Password in Windows VM remains unchanged"
      echo "   To match: Change password in Windows first, then update here"
      echo ""

      PASSWORD=$(gum input --placeholder="Enter new password for docker-compose" --password --header="New Windows password:")
      if [[ -z "$PASSWORD" ]]; then
        echo "Password cannot be empty"
        exit 1
      fi
      PASSWORD_DISPLAY="(changed)"
    else
      # Keep previous password (already extracted before COMPOSE_FILE was deleted)
      if [[ -z "$PREVIOUS_PASSWORD" ]]; then
        echo ""
        msg_warning "Warning: Could not extract previous password from docker-compose.yml"
        echo "   Please enter password for configuration:"
        echo ""
        PASSWORD=$(gum input --placeholder="Enter password" --password --header="Windows password:")
        if [[ -z "$PASSWORD" ]]; then
          echo "Password cannot be empty"
          exit 1
        fi
        PASSWORD_DISPLAY="(re-entered)"
      else
        PASSWORD="$PREVIOUS_PASSWORD"
        PASSWORD_DISPLAY="(kept previous)"
      fi
    fi
  else
    # Fresh install - prompt for password
    PASSWORD=$(gum input --placeholder="Password (Press enter to use default: admin)" --password --header="Enter Windows password:")
    if [[ -z "$PASSWORD" ]]; then
      PASSWORD="admin"
      PASSWORD_DISPLAY="(default)"
    else
      PASSWORD_DISPLAY="(user-defined)"
    fi
  fi

  # Validate password (no quotes or special YAML chars)
  if [[ "$PASSWORD" =~ [\"\'\`\$\\] ]]; then
    msg_error "Password cannot contain quotes, backticks, dollar signs, or backslashes"
    echo "   These characters would break the configuration file"
    exit 1
  fi

  mkdir -p "$HOME/Windows"

  echo ""
  echo "Detecting GPU configuration..."

  HAS_DEDICATED_GPU=false
  GPU_INFO=""
  GPU_PASSTHROUGH_READY=false

  # Looking Glass requires dedicated GPU (NVIDIA/AMD/Intel Arc), not integrated
  if command -v lspci &>/dev/null; then
    GPU_INFO=$(lspci | grep -iE 'VGA|3D|Display' | grep -E 'NVIDIA|AMD|Arc' | grep -vE 'Intel.*(UHD|HD Graphics [0-9]{3,4}$)' | head -1)
    if [[ -n "$GPU_INFO" ]]; then
      HAS_DEDICATED_GPU=true

      # Extract clean GPU name (e.g., "NVIDIA RTX 5070" instead of full lspci output)
      # Use last bracket for AMD GPUs with multiple brackets: [AMD/ATI] ... [Radeon RX 7900 XT]
      GPU_NAME=$(echo "$GPU_INFO" | grep -oP '\[[^\]]+\]' | tail -1 | tr -d '[]')

      # Add vendor prefix and remove redundant prefixes
      if [[ -n "$GPU_NAME" ]]; then
        if [[ "$GPU_INFO" =~ NVIDIA ]]; then
          GPU_NAME="${GPU_NAME#GeForce }"
          GPU_NAME="NVIDIA $GPU_NAME"
        elif [[ "$GPU_INFO" =~ AMD|ATI ]]; then
          GPU_NAME="${GPU_NAME#Radeon }"
          GPU_NAME="AMD $GPU_NAME"
        elif [[ "$GPU_INFO" =~ Arc ]]; then
          GPU_NAME="Intel $GPU_NAME"
        fi
      else
        # Fallback if no brackets found (unlikely but safe)
        GPU_NAME="$GPU_INFO"
      fi

      msg_success "Dedicated GPU detected: $GPU_NAME"
    else
      msg_warning "No dedicated GPU detected (NVIDIA/AMD/Arc required for Looking Glass)"
    fi
  else
    msg_warning "lspci not available - cannot detect GPU"
  fi

  # Check GPU passthrough configuration
  if [[ "$HAS_DEDICATED_GPU" == true ]]; then
    echo ""
    echo "Checking GPU passthrough configuration..."

    if command -v omarchy-gpu-passthrough-info &>/dev/null; then
      # Check if GPU passthrough is already configured
      if omarchy-gpu-passthrough-info is-configured &>/dev/null; then
        msg_success "GPU passthrough configured and ready"
        echo "GPU passthrough provides:"
        echo "  • Native GPU performance in Windows VM"
        echo "  • Full GPU features (ray tracing, DLSS, gaming)"
        echo "  • Looking Glass support"
        echo "Note: GPU will be bound to VM and unavailable to host during VM runtime"
        echo ""

        if gum confirm "Enable GPU passthrough for this Windows VM?"; then
          GPU_PASSTHROUGH_READY=true
          GPU_PASSTHROUGH_ENABLED=true

          # Load GPU configuration (PCI address, audio, IOMMU group)
          GPU_PCI_ADDR=""
          GPU_AUDIO_PCI=""
          GPU_IOMMU_GROUP=""
          GPU_CONFIG=$(omarchy-gpu-passthrough-info get-docker-config 2>/dev/null)
          if [[ -n "$GPU_CONFIG" ]]; then
            read GPU_PCI_ADDR GPU_AUDIO_PCI GPU_IOMMU_GROUP <<<"$GPU_CONFIG"
          fi

          msg_success "GPU passthrough will be enabled for this VM"
        else
          GPU_PASSTHROUGH_READY=false
          GPU_PASSTHROUGH_ENABLED=false
          msg_success "VM will use CPU-only graphics (QXL)"
          echo "  You can enable GPU passthrough later by reinstalling"
        fi
      else
        msg_warning "GPU passthrough not configured yet"
        echo ""
        echo "GPU passthrough provides:"
        echo "  • Native GPU performance in Windows VM"
        echo "  • Full GPU features (ray tracing, DLSS, etc.)"
        echo "  • Best gaming and GPU compute performance"
        echo ""

        if gum confirm "Configure GPU passthrough now?"; then
          echo ""
          # Run GPU passthrough setup
          if omarchy-gpu-passthrough setup; then
            echo ""
            msg_success "GPU passthrough configured successfully!"
            echo ""
            msg_warning "SYSTEM REBOOT REQUIRED"
            echo ""
            echo "Kernel parameters have been configured and require reboot."
            echo ""
            echo "After reboot:"
            echo "  1. Verify GPU passthrough: omarchy-gpu-passthrough info verify"
            echo "  2. Re-run Windows VM installation: omarchy-windows-vm install"
            echo ""
            exit 0
          else
            msg_warning "GPU passthrough setup was cancelled or failed"
            echo ""

            if ! gum confirm "Continue without GPU passthrough?"; then
              echo "Installation cancelled by user"
              exit 1
            fi

            msg_info "Continuing without GPU passthrough"
            msg_info "You can configure it later with: omarchy-gpu-passthrough setup"
            echo ""
          fi
        else
          msg_info "Skipping GPU passthrough configuration"
          msg_info "You can configure it later with: omarchy-gpu-passthrough setup"
          echo ""
        fi
      fi
    else
      msg_warning "omarchy-gpu-passthrough not found in PATH"
      echo "   GPU passthrough configuration not available"
      echo ""
    fi
  fi

  NEEDS_REBOOT_FOR_LG=false
  LG_REBOOT_REASON=""
  LG_ENABLED=false

  # Looking Glass only makes sense with GPU passthrough
  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
    if is_looking_glass_ready; then
      echo ""
      msg_success "Looking Glass already installed and ready"
      LG_ENABLED=true
    else
      echo ""
      # Show dummy plug requirement BEFORE prompting
      msg_warning "Looking Glass Requirements:"
      echo ""
      echo "   Your GPU MUST have a monitor or dummy plug connected!"
      echo "   Windows will disable the GPU without a connected display."
      echo ""
      echo "   Options:"
      echo "   • Connect a real monitor to the GPU"
      echo "   • Use an HDMI/DisplayPort dummy plug (4K 60Hz recommended)"
      echo ""

      if gum confirm "Do you have a monitor or dummy plug connected to the GPU?"; then
        if gum confirm "Enable Looking Glass support?"; then
          LG_ENABLED=true
          echo "Installing Looking Glass client..."

          install_looking_glass_client
          LG_INSTALL_STATUS=$?

          if [[ "$LG_INSTALL_STATUS" -eq 0 ]]; then
            msg_success "Looking Glass client ready"
          elif [[ "$LG_INSTALL_STATUS" -eq 1 ]]; then
            msg_warning "Looking Glass client installed - reboot required"
            NEEDS_REBOOT_FOR_LG=true
          else
            msg_error "Looking Glass client installation failed"
            [[ -d "$HOME/.config/windows/oem" ]] && rm -rf "$HOME/.config/windows/oem" && echo "   Cleaned up partial installation"
            echo "   You can install it manually later: omarchy-looking-glass-install"
            if ! gum confirm "Continue without Looking Glass?"; then
              echo "Installation cancelled"
              exit 1
            fi
            LG_ENABLED=false
          fi
        else
          # User said NO to Looking Glass despite having dummy plug
          echo ""
          echo "ℹ️  Without Looking Glass, you can connect to Windows VM via:"
          echo "   • VNC (browser): http://127.0.0.1:8006"
          echo "   • RDP: omarchy-windows-vm launch"
          echo ""
          echo "  Comparison:"
          echo "   • VNC/RDP latency: ~50-100ms"
          echo "   • Looking Glass latency: ~1-2ms"
          echo ""
          echo "  You can add Looking Glass later with: omarchy-looking-glass-install"
          echo ""
        fi
      else
        # User does NOT have monitor/dummy plug connected
        echo ""
        echo "ℹ️  Looking Glass requires a monitor or dummy plug connected to GPU"
        echo ""
        echo "Without a display connected:"
        echo "  • Windows will disable the GPU"
        echo "  • Looking Glass will not work"
        echo ""
        echo "You can:"
        echo "  1. Add a monitor or dummy plug later"
        echo "  2. Reinstall Windows VM: omarchy-windows-vm remove && omarchy-windows-vm install"
        echo ""
        echo "For now, you can connect to Windows VM via:"
        echo "  • VNC (browser): http://127.0.0.1:8006"
        echo "  • RDP: omarchy-windows-vm launch"
        echo ""
      fi
    fi
  fi

  # Display final configuration summary with GPU/LG status
  echo ""
  GPU_STATUS="Disabled (CPU-only graphics)"
  LG_STATUS="Disabled"
  CONNECTION_INFO="RDP + VNC"

  if [[ "${GPU_PASSTHROUGH_ENABLED:-false}" == true ]]; then
    GPU_STATUS="Enabled"
    if [[ "$LG_ENABLED" == true ]]; then
      LG_STATUS="Enabled"
      CONNECTION_INFO="Looking Glass + RDP + VNC"
    else
      CONNECTION_INFO="RDP + VNC"
    fi
  fi

  # Pre-check: Verify GPU is not in use (before showing summary)
  if [[ "${GPU_PASSTHROUGH_ENABLED:-false}" == true ]]; then
    if command -v lspci &>/dev/null && [[ -n "${GPU_PCI_ADDR:-}" ]]; then
      echo ""
      echo "Checking GPU availability..."

      # Get current GPU driver
      CURRENT_DRIVER=$(lspci -k -s "$GPU_PCI_ADDR" 2>/dev/null | grep "Kernel driver in use" | awk '{print $5}')

      # Check if GPU is in use
      GPU_PROCESSES=""
      if [[ "$CURRENT_DRIVER" == "nvidia" ]]; then
        GPU_PROCESSES=$(sudo fuser -v /dev/nvidia* 2>&1 | grep -v "USER\|kernel" || true)
      elif [[ "$CURRENT_DRIVER" == "amdgpu" ]]; then
        GPU_PROCESSES=$(sudo fuser -v /dev/dri/card* /dev/dri/renderD* 2>&1 | grep -v "USER\|kernel" || true)
      fi

      if [[ -n "$GPU_PROCESSES" ]]; then
        echo ""
        msg_warning "GPU is currently in use by processes:"
        echo ""
        echo "$GPU_PROCESSES"
        echo ""

        if gum confirm "Kill all GPU processes before continuing?"; then
          # Extract process names and kill
          PROCESS_NAMES=$(echo "$GPU_PROCESSES" | awk '{print $NF}' | grep -v "^$" | sort -u)

          for proc in $PROCESS_NAMES; do
            echo "Killing $proc..."
            sudo pkill -9 "$proc" 2>/dev/null || true
          done

          sleep 2

          # Re-check after killing
          GPU_PROCESSES_AFTER=""
          if [[ "$CURRENT_DRIVER" == "nvidia" ]]; then
            GPU_PROCESSES_AFTER=$(sudo fuser -v /dev/nvidia* 2>&1 | grep -v "USER\|kernel" || true)
          elif [[ "$CURRENT_DRIVER" == "amdgpu" ]]; then
            GPU_PROCESSES_AFTER=$(sudo fuser -v /dev/dri/card* /dev/dri/renderD* 2>&1 | grep -v "USER\|kernel" || true)
          fi

          if [[ -z "$GPU_PROCESSES_AFTER" ]]; then
            msg_success "GPU processes terminated"
          else
            echo ""
            msg_warning "Some GPU processes still running:"
            echo "$GPU_PROCESSES_AFTER"
            echo ""
            echo "Installation cancelled - close GPU applications manually"
            exit 1
          fi
        else
          echo ""
          echo "Installation cancelled - GPU in use"
          echo "Close GPU applications manually, then run install again"
          exit 1
        fi
      fi

      msg_success "GPU available for passthrough"
      echo ""
    fi
  fi

  # Different header and confirmation for Quick reinstall vs Fresh install
  if [[ "${SKIP_OEM_AUTORUN:-false}" == "true" ]]; then
    SUMMARY_TITLE="Updated Configuration"
    CONFIRM_MESSAGE="Apply this configuration to existing Windows VM?"
  else
    SUMMARY_TITLE="Final Configuration Summary"
    CONFIRM_MESSAGE="Start installation with this configuration?"
  fi

  gum style \
    --border double \
    --padding "1 2" \
    --margin "1" \
    --align left \
    --bold \
    "$SUMMARY_TITLE" \
    "" \
    "Resources:" \
    "  RAM:              $SELECTED_RAM" \
    "  CPU:              $SELECTED_CORES cores" \
    "  Disk:             $SELECTED_DISK" \
    "" \
    "Credentials:" \
    "  Username:         $USERNAME" \
    "  Password:         $PASSWORD_DISPLAY" \
    "" \
    "Graphics:" \
    "  GPU Passthrough:  $GPU_STATUS" \
    "  Looking Glass:    $LG_STATUS"

  echo ""
  if ! gum confirm "$CONFIRM_MESSAGE"; then
    echo "Configuration cancelled by user"
    exit 1
  fi

  echo ""
  [[ "${SKIP_OEM_AUTORUN:-false}" == "false" ]] && echo "Setting up Windows auto-installation..." || echo "Updating Windows configuration..."

  OEM_DIR="$HOME/.config/windows/oem"
  mkdir -p "$OEM_DIR/wallpaper"

  # Validate and resolve OMARCHY_PATH if set
  if [[ -n "$OMARCHY_PATH" ]] && [[ -d "$OMARCHY_PATH" ]]; then
    OMARCHY_PATH=$(realpath "$OMARCHY_PATH" 2>/dev/null)

    if [[ -d "$OMARCHY_PATH" ]]; then
      # Copy wallpaper if exists
      if [[ -f "$OMARCHY_PATH/themes/rose-pine/backgrounds/3-leafy-dawn-omarchy.png" ]]; then
        cp "$OMARCHY_PATH/themes/rose-pine/backgrounds/3-leafy-dawn-omarchy.png" "$OEM_DIR/wallpaper/omarchy.png"
      fi

      # Get git version
      if [[ -d "$OMARCHY_PATH/.git" ]]; then
        SCRIPT_VERSION="$(git -C "$OMARCHY_PATH" rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
      else
        SCRIPT_VERSION="unknown"
      fi
    else
      SCRIPT_VERSION="unknown"
    fi
  else
    SCRIPT_VERSION="unknown"
  fi
  create_oem_powershell_script "$OEM_DIR" "$SCRIPT_VERSION"
  create_oem_batch_script "$OEM_DIR"

  # Always download Looking Glass + SPICE (future-proof for quick reinstalls)
  # Silent download - only show errors
  echo "Preparing OEM configuration..."

  LG_ZIP="$OEM_DIR/looking-glass-host.zip"
  LG_INSTALLER="$OEM_DIR/looking-glass-host-setup.exe"

  if [[ ! -f "$LG_INSTALLER" ]]; then
    if curl -L --max-time 300 --connect-timeout 30 -o "$LG_ZIP" "https://looking-glass.io/artifact/stable/host" 2>/dev/null; then
      if unzip -q -o "$LG_ZIP" -d "$OEM_DIR" 2>/dev/null; then
        rm "$LG_ZIP"
      else
        msg_warning "Looking Glass extraction failed"
        echo "   Try manually: unzip $LG_ZIP -d $OEM_DIR"
        echo "   Or download from: https://looking-glass.io/downloads"
        rm -f "$LG_ZIP"
      fi
    else
      msg_warning "Looking Glass download failed (check internet connection)"
      echo "   Download manually: https://looking-glass.io/downloads"
      echo "   Save to: $OEM_DIR/looking-glass-host-setup.exe"
    fi
  fi

  SPICE_INSTALLER="$OEM_DIR/spice-guest-tools-setup.exe"

  if [[ ! -f "$SPICE_INSTALLER" ]]; then
    if ! curl -L --tlsv1.2 --max-time 300 --connect-timeout 30 -o "$SPICE_INSTALLER" "https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe" 2>/dev/null; then
      msg_warning "SPICE Guest Tools download failed (check internet connection)"
      echo "   Download manually: https://www.spice-space.org/download/windows/spice-guest-tools/spice-guest-tools-latest.exe"
      echo "   Save to: $OEM_DIR/spice-guest-tools-setup.exe"
    fi
  fi

  IVSHMEM_SIZE=${IVSHMEM_SIZE:-128}

  # Detect GPU passthrough configuration
  GPU_PASSTHROUGH_ENABLED=false
  GPU_PCI_ADDR=""
  GPU_AUDIO_PCI=""
  GPU_IOMMU_GROUP=""

  if [[ "$LG_ENABLED" == true ]] && command -v omarchy-gpu-passthrough-info &>/dev/null; then
    if omarchy-gpu-passthrough-info is-configured &>/dev/null; then
      GPU_PASSTHROUGH_ENABLED=true
      GPU_CONFIG=$(omarchy-gpu-passthrough-info get-docker-config 2>/dev/null)
      if [[ -n "$GPU_CONFIG" ]]; then
        read GPU_PCI_ADDR GPU_AUDIO_PCI GPU_IOMMU_GROUP <<<"$GPU_CONFIG"
      fi
    fi
  fi

  # Clean up old state files (for Quick reinstall only, after user confirmation)
  # Note: docker-compose.yml will be overwritten by create_docker_compose_config, no need to delete
  if [[ "${QUICK_REINSTALL_CLEANUP:-false}" == "true" ]]; then
    rm -f "$HOME/Windows/installation-complete.txt" 2>/dev/null
    rm -f "$HOME/.local/share/applications/windows-vm.desktop" "$HOME/.local/share/applications/windows-looking-glass.desktop" 2>/dev/null

    # Update desktop database after removing old icons (new icons will be created shortly)
    if command -v update-desktop-database &>/dev/null; then
      update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
    fi
  fi

  create_docker_compose_config "$COMPOSE_FILE" "$SELECTED_RAM" "$SELECTED_CORES" "$SELECTED_DISK" \
    "$USERNAME" "$PASSWORD" "$LG_ENABLED" "$IVSHMEM_SIZE" \
    "$GPU_PASSTHROUGH_ENABLED" "$GPU_PCI_ADDR" "$GPU_AUDIO_PCI" "$GPU_IOMMU_GROUP"

  echo ""
  msg_success "Configuration saved to: $COMPOSE_FILE"
  echo ""
  msg_warning "Security Note:"
  echo "  Password stored in plain text in docker-compose.yml"
  echo "  Keep this file secure and don't share it"
  echo ""

  # Create desktop entries (must be done AFTER LG_ENABLED is determined)
  mkdir -p "$HOME/.local/share/applications/icons"

  # Install Windows VM icon
  ICON_SOURCE="$SCRIPT_DIR/../applications/icons/windows.png"
  if [[ -f "$ICON_SOURCE" ]]; then
    cp "$ICON_SOURCE" "$HOME/.local/share/applications/icons/windows.png"
  else
    msg_warning "Windows icon not found at: $ICON_SOURCE"
    msg_info "Desktop entries will use default icon"
  fi

  # Create Windows (RDP) desktop entry
  cat <<EOF >"$HOME/.local/share/applications/windows-vm.desktop"
[Desktop Entry]
Name=Windows
Comment=Start Windows VM via Docker and connect with RDP
Exec=uwsm-app -- omarchy-windows-vm launch --keep-alive
Icon=$HOME/.local/share/applications/icons/windows.png
Terminal=false
Type=Application
Categories=System;Virtualization;
EOF

  # Create Windows [Looking Glass] desktop entry if enabled
  if [[ "$LG_ENABLED" == true ]]; then
    cat <<EOF >"$HOME/.local/share/applications/windows-looking-glass.desktop"
[Desktop Entry]
Name=Windows [Looking Glass]
Comment=Connect to Windows VM via Looking Glass
Exec=uwsm-app -- omarchy-windows-vm launch --lg --keep-alive
Icon=$HOME/.local/share/applications/icons/windows.png
Terminal=false
Type=Application
Categories=System;Virtualization;
EOF
  fi

  # Set proper permissions for desktop files
  chmod 644 "$HOME/.local/share/applications/windows-vm.desktop" 2>/dev/null
  [[ -f "$HOME/.local/share/applications/windows-looking-glass.desktop" ]] &&
    chmod 644 "$HOME/.local/share/applications/windows-looking-glass.desktop" 2>/dev/null

  # Update desktop database to make icons appear in application menu
  if command -v update-desktop-database &>/dev/null; then
    update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
  fi

  # Bind GPU to VFIO before starting Docker (if GPU passthrough enabled)
  if [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
    if command -v omarchy-gpu-passthrough &>/dev/null; then
      # Check current GPU driver
      CURRENT_DRIVER=$(lspci -k -s "$GPU_PCI_ADDR" 2>/dev/null | grep "Kernel driver in use" | awk '{print $5}')

      if [[ "$CURRENT_DRIVER" != "vfio-pci" ]]; then
        echo "Binding GPU to VFIO for passthrough..."
        if omarchy-gpu-passthrough mode vm 2>&1; then
          msg_success "GPU bound to VFIO successfully"
        else
          echo ""
          msg_error "Failed to bind GPU to VFIO!"
          echo ""
          echo "   GPU passthrough requires VFIO driver binding."
          echo "   Fix: omarchy-gpu-passthrough mode vm"
          echo ""
          exit 1
        fi
      else
        msg_success "GPU bound to VFIO (ready for passthrough)"
      fi
    else
      echo ""
      msg_error "GPU passthrough enabled but omarchy-gpu-passthrough not found!"
      echo ""
      echo "   GPU passthrough requires omarchy-gpu-passthrough tools."
      echo "   These should be installed in your PATH."
      echo ""
      echo "   Fix: Disable GPU passthrough and use CPU-only VM"
      echo "   Then reinstall with GPU passthrough disabled"
      echo ""
      exit 1
    fi
    echo ""
  fi

  # Ensure Docker image has SPICE support (required for Looking Glass)
  if [[ "$LG_ENABLED" == true ]]; then
    if ! ensure_dockurr_windows_with_spice; then
      msg_error "Failed to prepare Docker image with SPICE support"
      echo "   Looking Glass requires SPICE for keyboard/mouse input"
      echo ""
      exit 1
    fi
  fi

  # Start or restart docker-compose with user's config
  msg_info "Starting Windows VM..."
  echo ""

  # Verify Looking Glass device exists before starting VM
  if [[ "$LG_ENABLED" == true ]]; then
    if [[ ! -e /dev/kvmfr0 ]]; then
      echo ""
      msg_error "Looking Glass device /dev/kvmfr0 not found!"
      echo ""
      echo "   Looking Glass requires /dev/kvmfr0 device from kvmfr kernel module."
      echo ""
      echo "   Fix:"
      echo "   1. Reload kvmfr module: sudo rmmod kvmfr && sudo modprobe kvmfr"
      echo "   2. Verify device exists: ls -la /dev/kvmfr0"
      echo "   3. If still missing: reboot (module will auto-load on boot)"
      echo ""
      echo "   Or reinstall Looking Glass: omarchy-looking-glass-install"
      echo ""
      exit 1
    fi
  fi

  # Start container (suppress verbose Docker output)
  if ! docker-compose -f "$COMPOSE_FILE" up -d >/dev/null 2>&1; then
    echo ""
    msg_error "Failed to start Windows VM!"
    echo ""
    echo "   Common causes:"
    echo "   • Docker daemon not running: sudo systemctl start docker"
    echo "   • Port already in use (check if another VM is running)"
    echo "   • Permission issues (add yourself to docker group)"
    echo "   • Invalid docker-compose.yml configuration"
    echo ""
    echo "   Troubleshoot:"
    echo "   • View logs: docker logs omarchy-windows"
    echo "   • Check config: cat $COMPOSE_FILE"
    echo "   • Check daemon: systemctl status docker"
    exit 1
  fi

  # Verify container is actually running (docker-compose up -d returns 0 even if container crashes)
  sleep 2

  if ! docker ps --filter "name=omarchy-windows" --filter "status=running" --format "{{.Names}}" | grep -q "omarchy-windows"; then
    echo ""
    msg_error "Container started but crashed immediately!"
    echo ""

    # Try to extract ERROR lines first, fall back to last 10 lines if none found
    ERROR_LOGS=$(docker logs omarchy-windows 2>&1 | grep -i "ERROR:" | head -5)

    if [[ -n "$ERROR_LOGS" ]]; then
      echo "   Error details:"
      echo "$ERROR_LOGS" | sed 's/^/   /'
      echo ""
    else
      # No ERROR lines found, show last 10 lines of logs
      RECENT_LOGS=$(docker logs omarchy-windows 2>&1 | tail -10)
      if [[ -n "$RECENT_LOGS" ]]; then
        echo "   Recent logs (last 10 lines):"
        echo "$RECENT_LOGS" | sed 's/^/   /'
        echo ""
      fi
    fi

    echo "   View full logs:"
    echo "   docker logs omarchy-windows"
    echo ""
    echo "   Common issues:"
    echo "   • Missing QEMU modules (check logs for 'There is no option group')"
    echo "   • GPU passthrough configuration error"
    echo "   • Insufficient permissions or resources"
    exit 1
  fi

  msg_success "Docker container started"
  echo ""

  # Check if this is quick reinstall with VM already booted and RDP ready
  if [[ "${SKIP_OEM_AUTORUN:-false}" == "true" ]] && nc -z 127.0.0.1 3389 2>/dev/null; then
    msg_success "Windows is ready (RDP service responding)"
    echo ""

    # Auto-launch RDP or Looking Glass
    if [[ "$LG_ENABLED" == true ]]; then
      echo "Launching Looking Glass..."
      echo "  Toggle fullscreen: Scroll Lock"
      echo ""
      sleep 1
      launch_windows --lg
    else
      echo "Launching RDP connection..."
      echo "  Toggle fullscreen: Super + F"
      echo ""
      sleep 1
      # Extract credentials
      WIN_USER=$(grep -E '^\s*USERNAME:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
      WIN_PASS=$(grep -E '^\s*PASSWORD:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
      connect_rdp "$WIN_USER" "$WIN_PASS" true
    fi
    return 0
  fi

  if [[ "${SKIP_OEM_AUTORUN:-false}" == "false" ]]; then
    echo "Windows installation starting..."
  else
    echo "Starting Windows VM from existing disk..."
  fi
  echo ""

  # Launch monitoring interface based on Looking Glass availability
  if [[ "$LG_ENABLED" == true ]] && [[ "$GPU_PASSTHROUGH_ENABLED" == true ]]; then
    # Auto-fix Looking Glass config if using old SPICE socket path
    LG_CONFIG="$HOME/.config/looking-glass/client.ini"
    if [[ -f "$LG_CONFIG" ]]; then
      if grep -q "host=/tmp/spice/spice.sock" "$LG_CONFIG" 2>/dev/null; then
        echo "  Updating Looking Glass config to new SPICE socket path..."
        sed -i 's|host=/tmp/spice/spice.sock|host=/var/run/omarchy-windows/spice.sock|g' "$LG_CONFIG"
        msg_success "Config updated"
      fi
    fi

    echo "Monitor installation via VNC: http://127.0.0.1:8006"
    echo "  Looking Glass will launch automatically after installation completes"
    echo "  Detailed logs: docker logs omarchy-windows -f"
    echo ""

    sleep 2

    # Open VNC in browser for installation monitoring
    xdg-open "http://127.0.0.1:8006" &>/dev/null &
  else
    echo "Monitor progress: http://127.0.0.1:8006"
    echo "  Detailed logs: docker logs omarchy-windows -f"
    echo ""

    sleep 2

    # Open VNC in browser
    xdg-open "http://127.0.0.1:8006" &>/dev/null &
  fi

  [[ "${SKIP_OEM_AUTORUN:-false}" == "false" ]] &&
    monitor_installation_progress "$USERNAME" "$PASSWORD" "true" "$LG_ENABLED" ||
    monitor_installation_progress "$USERNAME" "$PASSWORD" "false" "$LG_ENABLED"

  if [[ "$NEEDS_REBOOT_FOR_LG" == true ]]; then
    echo ""
    if [[ "$LG_ENABLED" == true ]]; then
      echo "ℹ️  Looking Glass host will auto-install in Windows on first boot"
      echo ""
    fi
    if [[ "$LG_REBOOT_REASON" == "kvm group membership" ]]; then
      msg_warning "LOG OUT and LOG BACK IN required for Looking Glass (kvm group)"
      echo "   After re-login: omarchy-windows-vm launch --lg"
    else
      msg_warning "REBOOT REQUIRED for Looking Glass ($LG_REBOOT_REASON)"
      echo "   After reboot: omarchy-windows-vm launch --lg"
    fi
    echo ""
  elif [[ "$LG_ENABLED" == true ]]; then
    echo ""
    echo "ℹ️  Looking Glass host will auto-install in Windows on first boot"
    echo ""
  fi
}

remove_windows() {
  echo "Removing Windows VM configuration..."
  echo ""
  echo "This will remove Docker container and config files."
  echo "VM disk and your data will be preserved."
  echo ""

  if ! gum confirm "Remove VM configuration only (keep VM disk)?"; then
    echo "Cancelled"
    return 0
  fi

  # Stop and remove container
  echo "• Stopping container..."
  docker-compose -f "$COMPOSE_FILE" down 2>/dev/null || true

  # Remove Docker image
  echo "• Removing Docker image..."
  if docker rmi dockurr/windows >/dev/null 2>&1; then
    msg_success "Docker image removed"
  else
    echo "  ℹ️  Image already removed"
  fi

  # Remove desktop files and shortcuts
  echo "• Removing desktop shortcuts..."
  rm -f "$HOME/.local/share/applications/windows-vm.desktop"
  rm -f "$HOME/.local/share/applications/windows-looking-glass.desktop"

  # Update desktop database to remove icons from application menu
  if command -v update-desktop-database &>/dev/null; then
    update-desktop-database "$HOME/.local/share/applications" 2>/dev/null || true
  fi

  # Remove installation log files (not user data)
  echo "• Removing installation logs..."
  rm -f "$HOME/Windows/install-log.txt"
  rm -f "$HOME/Windows/installation-complete.txt"

  # Remove configuration (but keep data)
  echo "• Removing configuration..."
  rm -rf "$HOME/.config/windows"

  echo ""
  msg_success "Windows VM configuration removed!"
  echo ""
  echo "Preserved:"
  echo "  ✅ VM disk: $HOME/.windows/ (reusable for quick reinstall)"
  echo "  ✅ Shared files: $HOME/Windows/ (your data)"
  echo ""
  echo "To completely remove all data:"
  echo "  sudo rm -rf $HOME/.windows/      # Delete VM disk and Windows OS"
}

launch_windows() {
  KEEP_ALIVE=false
  USE_LOOKING_GLASS=false
  USER_PROVIDED_PARAMS=false

  # Parse command line arguments
  while [[ "$#" -gt 0 ]]; do
    case "$1" in
    --keep-alive | -k)
      KEEP_ALIVE=true
      USER_PROVIDED_PARAMS=true
      shift
      ;;
    --looking-glass | --lg)
      USE_LOOKING_GLASS=true
      USER_PROVIDED_PARAMS=true
      shift
      ;;
    *)
      shift
      ;;
    esac
  done

  check_vm_configured
  check_docker_running

  # Interactive mode if no params provided
  if [[ "$USER_PROVIDED_PARAMS" == false ]]; then
    # Check if Looking Glass is available
    LG_AVAILABLE=false
    if grep -q "ivshmem-plain" "$COMPOSE_FILE" 2>/dev/null &&
      command -v looking-glass-client &>/dev/null &&
      grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
      LG_AVAILABLE=true
    fi

    # Combined prompt for connection method and lifecycle
    if [[ "$LG_AVAILABLE" == true ]]; then
      echo "Windows VM Launch Options:"
      echo ""
      echo "Connection method:"
      echo "  • Looking Glass: Ultra-low latency (GPU passthrough)"
      echo "  • RDP: Standard remote desktop"
      echo ""
      echo "VM lifecycle:"
      echo "  • Auto-stop: VM stops when you disconnect"
      echo "  • Keep-alive: VM keeps running in background"
      echo ""

      LAUNCH_CONFIG=$(gum choose --selected="Looking Glass + Auto-stop" \
        "Looking Glass + Auto-stop" \
        "Looking Glass + Keep-alive" \
        "RDP + Auto-stop" \
        "RDP + Keep-alive")

      echo ""

      # Parse combined choice
      if [[ "$LAUNCH_CONFIG" == "Looking Glass"* ]]; then
        USE_LOOKING_GLASS=true
      fi

      if [[ "$LAUNCH_CONFIG" == *"Keep-alive"* ]]; then
        KEEP_ALIVE=true
      fi
    else
      # LG not available, only offer RDP options
      echo "Windows VM Launch Options:"
      echo ""
      echo "Connection: RDP (standard remote desktop)"
      echo "  (Looking Glass not configured)"
      echo ""
      echo "VM lifecycle:"
      echo "  • Auto-stop: VM stops when you disconnect"
      echo "  • Keep-alive: VM keeps running in background"
      echo ""

      LAUNCH_CONFIG=$(gum choose --selected="RDP + Auto-stop" \
        "RDP + Auto-stop" \
        "RDP + Keep-alive")

      echo ""

      if [[ "$LAUNCH_CONFIG" == *"Keep-alive"* ]]; then
        KEEP_ALIVE=true
      fi
    fi
  fi

  CONTAINER_STATUS=$(get_container_status)

  WAS_ALREADY_RUNNING=false
  if [[ "$CONTAINER_STATUS" == "running" ]]; then
    WAS_ALREADY_RUNNING=true
  fi

  if [[ "$CONTAINER_STATUS" != "running" ]]; then
    echo "Starting Windows VM..."

    # Check if GPU passthrough is configured in docker-compose.yml
    if grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
      echo "  Detected GPU passthrough configuration"

      # Load GPU configuration and auto-bind if needed
      if command -v omarchy-gpu-passthrough-info &>/dev/null; then
        if omarchy-gpu-passthrough-info is-configured &>/dev/null; then
          # Check if GPU is already bound to VFIO
          GPU_CONFIG=$(omarchy-gpu-passthrough-info get-docker-config 2>/dev/null)
          if [[ -n "$GPU_CONFIG" ]]; then
            read GPU_PCI_ADDR GPU_AUDIO IOMMU_GROUP <<<"$GPU_CONFIG"

            # Validate PCI address format (security check)
            if [[ ! "$GPU_PCI_ADDR" =~ ^([0-9a-fA-F]{4}:)?[0-9a-fA-F]{2}:[0-9a-fA-F]{2}\.[0-7]$ ]]; then
              msg_warning "Invalid PCI address format: $GPU_PCI_ADDR"
            else
              # Check current driver binding
              CURRENT_DRIVER=$(lspci -k -s "$GPU_PCI_ADDR" 2>/dev/null | grep "Kernel driver in use" | awk '{print $5}')

              if [[ "$CURRENT_DRIVER" != "vfio-pci" ]]; then
                echo "  GPU not bound to VFIO, binding now..."
                if command -v omarchy-gpu-passthrough &>/dev/null; then
                  if omarchy-gpu-passthrough mode vm 2>&1; then
                    msg_success "GPU switched to VM mode successfully"
                  else
                    msg_warning "GPU mode switch may have failed, check with: omarchy-gpu-passthrough mode"
                  fi
                fi
              else
                msg_success "GPU already bound to VFIO"
              fi
            fi
          fi
        fi
      fi

      # Create SPICE directory for socket
      if ! [[ -d "$SPICE_DIR" ]]; then
        echo "  Creating SPICE directory..."
        mkdir -p "$SPICE_DIR"
        chmod 770 "$SPICE_DIR"
        msg_success "SPICE directory created"
      fi
    fi

    # Send desktop notification
    notify_silent "Windows VM" "Starting... (15-30 seconds)" "normal"

    # Verify Looking Glass device exists before starting VM
    if grep -q "ivshmem-plain" "$COMPOSE_FILE" 2>/dev/null; then
      if [[ ! -e /dev/kvmfr0 ]]; then
        echo ""
        msg_error "Looking Glass device /dev/kvmfr0 not found!"
        echo ""
        echo "   Looking Glass requires /dev/kvmfr0 device from kvmfr kernel module."
        echo ""
        echo "   Fix:"
        echo "   1. Reload kvmfr module: sudo rmmod kvmfr && sudo modprobe kvmfr"
        echo "   2. Verify device exists: ls -la /dev/kvmfr0"
        echo "   3. If still missing: reboot (module will auto-load on boot)"
        echo ""
        echo "   Or reinstall Looking Glass: omarchy-looking-glass-install"
        echo ""
        notify_silent "Windows VM" "Looking Glass device not found" "critical"
        exit 1
      fi
    fi

    if ! docker-compose -f "$COMPOSE_FILE" up -d >/dev/null 2>&1; then
      msg_error "Failed to start Windows VM!"
      echo "   Try checking: omarchy-windows-vm status"
      echo "   View logs: docker logs omarchy-windows"
      notify_silent "Windows VM" "Failed to start Windows VM" "critical"
      exit 1
    fi

    # Wait for SPICE socket if GPU passthrough is enabled
    if grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
      echo "  Waiting for SPICE socket..."
      SPICE_WAIT=0
      while [[ "$SPICE_WAIT" -lt 30 ]]; do
        if [[ -S "$SPICE_SOCKET_PATH" ]]; then
          msg_success "SPICE socket created"
          # Fix permissions
          sudo chmod 666 "$SPICE_SOCKET_PATH" 2>/dev/null || true
          break
        fi
        sleep 1
        SPICE_WAIT=$((SPICE_WAIT + 1))
      done

      if [[ "$SPICE_WAIT" -ge 30 ]]; then
        msg_warning "SPICE socket not created within 30s"
        echo "     Looking Glass input may not work properly"
      fi
    fi
  fi

  # Fix SPICE socket permissions if GPU passthrough is enabled (even if container already running)
  if grep -q "vfio-pci" "$COMPOSE_FILE" 2>/dev/null; then
    if [[ -S "$SPICE_SOCKET_PATH" ]]; then
      # Check if socket is readable by current user
      if [[ ! -r "$SPICE_SOCKET_PATH" ]]; then
        sudo chmod 666 "$SPICE_SOCKET_PATH" 2>/dev/null || true
      fi
    fi
  fi

  # Wait for RDP port if not already open (check actual RDP state, not just container state)
  RDP_PORT_WAS_CLOSED=false
  if ! nc -z 127.0.0.1 3389 2>/dev/null; then
    RDP_PORT_WAS_CLOSED=true
    echo "Waiting for Windows VM to be ready..."
    WAIT_START=$(date +%s)
    WAIT_COUNT=0
    while ! nc -z 127.0.0.1 3389 2>/dev/null; do
      sleep 5
      WAIT_COUNT=$((WAIT_COUNT + 1))

      if [[ "$((WAIT_COUNT % 60))" -eq 0 ]]; then
        CURRENT_TIME=$(date +%s)
        TOTAL_ELAPSED=$((CURRENT_TIME - WAIT_START))
        echo ""
        msg_warning "Windows is taking longer than expected (${TOTAL_ELAPSED}s elapsed)"
        echo ""
        echo "Options:"
        echo "  1. Keep waiting - VM might still be installing"
        echo "  2. Check progress at: http://127.0.0.1:8006"
        echo "  3. View logs: docker logs -f omarchy-windows"
        echo ""
        read -p "Continue waiting? (Y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Nn]$ ]]; then
          echo "VM will keep running in background"
          echo "Connect later: omarchy-windows-vm launch"
          exit 0
        fi
      elif [[ "$((WAIT_COUNT % 6))" -eq 0 ]]; then
        CURRENT_TIME=$(date +%s)
        ELAPSED=$((CURRENT_TIME - WAIT_START))
        echo "Still waiting... (${ELAPSED}s elapsed)"
        echo "Check progress at: http://127.0.0.1:8006"
      fi
    done

    WAIT_END=$(date +%s)
    WAIT_TIME=$((WAIT_END - WAIT_START))
    msg_success "RDP port open (took ${WAIT_TIME}s)"
  fi

  if [[ "$USE_LOOKING_GLASS" == true ]]; then
    connect_looking_glass "$KEEP_ALIVE"

  else
    # Extract credentials for RDP connection
    WIN_USER=$(grep -E '^\s*USERNAME:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)
    WIN_PASS=$(grep -E '^\s*PASSWORD:' "$COMPOSE_FILE" | head -1 | sed -E 's/^[^:]*:[[:space:]]*"?([^"]*)"?[[:space:]]*$/\1/' | xargs)

    if [[ -z "$WIN_USER" ]] || [[ -z "$WIN_PASS" ]]; then
      msg_error "Failed to extract credentials from $COMPOSE_FILE"
      echo "   Configuration file may be corrupted or in unexpected format."
      echo ""
      echo "   Try reinstalling: omarchy-windows-vm remove && omarchy-windows-vm install"
      exit 1
    fi

    # Test RDP service readiness only if port was closed (service may not be fully initialized yet)
    if [[ "$RDP_PORT_WAS_CLOSED" == true ]]; then
      echo "Waiting for RDP service to become ready..."
      echo ""

      # Test RDP readiness with X.224 handshake
      MAX_WAIT=90
      RETRY_INTERVAL=5
      ELAPSED=0
      RDP_READY=false

      while [[ "$ELAPSED" -lt "$MAX_WAIT" ]]; do
        if test_rdp_ready; then
          RDP_READY=true
          break
        fi
        ELAPSED=$((ELAPSED + RETRY_INTERVAL))
        if [[ "$ELAPSED" -lt "$MAX_WAIT" ]]; then
          echo "  Testing RDP protocol... (${ELAPSED}s elapsed, next check in ${RETRY_INTERVAL}s)"
          sleep "$RETRY_INTERVAL"
        fi
      done

      echo ""
      if [[ "$RDP_READY" == true ]]; then
        msg_success "RDP service is ready and responding to protocol requests"
      else
        msg_warning "RDP service did not respond within ${MAX_WAIT}s"
        echo "   Proceeding anyway, but connection may fail"
      fi
      echo ""
    fi

    # Build the connection info
    if [[ "$KEEP_ALIVE" == true ]]; then
      LIFECYCLE="VM will keep running after RDP closes
To stop: omarchy-windows-vm stop"
    else
      LIFECYCLE="VM will auto-stop when RDP closes"
    fi

    gum style \
      --border normal \
      --padding "1 2" \
      --margin "1" \
      --align center \
      "Connecting to Windows VM" \
      "" \
      "$LIFECYCLE"

    # Wait for Windows services only if container was just started
    if [[ "$WAS_ALREADY_RUNNING" == false ]]; then
      echo "Waiting 10s for Windows services to fully initialize..."
      sleep 10
      echo ""
    fi
    echo "  Toggle fullscreen: Super + F"
    echo "  Close RDP window: Super + W (or shutdown Windows)"
    if [[ "$KEEP_ALIVE" == false ]]; then
      echo "  Ctrl+C            - Close terminal (RDP/VM keep running)"
    fi
    echo ""
    echo "  Manual connect: xfreerdp3 /u:$WIN_USER /p:yourPassword /v:127.0.0.1:3389 (requires running VM)"
    echo ""

    # Connect with RDP (foreground mode)
    connect_rdp "$WIN_USER" "$WIN_PASS" false

    # After RDP closes, stop the container unless --keep-alive was specified
    if [[ "$KEEP_ALIVE" == false ]]; then
      echo ""
      echo "RDP session closed. Stopping Windows VM..."
      docker-compose -f "$COMPOSE_FILE" stop
      echo "Windows VM stopped."
      echo ""
      echo "ℹ️  Container is stopped but preserved for fast restart"
      echo "   Quick start: omarchy-windows-vm launch"
      echo "   Full cleanup: omarchy-windows-vm stop (removes container)"
    else
      echo ""
      echo "RDP session closed. Windows VM is still running."
      echo "To stop it: omarchy-windows-vm stop"
    fi
  fi
}

stop_windows() {
  check_vm_configured

  # Check if GPU restore will be needed (read once, use multiple times)
  local gpu_mode=""
  if [[ -f /var/run/omarchy-vm-gpu-mode ]]; then
    gpu_mode=$(cat /var/run/omarchy-vm-gpu-mode 2>/dev/null)
  fi

  # Pre-authenticate sudo immediately before docker operations
  # (GPU restore needs sudo, better to ask upfront than mid-operation)
  if [[ "$gpu_mode" == "vm" ]]; then
    sudo -v
  fi

  echo "Stopping Windows VM and removing container..."
  docker-compose -f "$COMPOSE_FILE" down
  echo "Windows VM stopped and container removed."
  echo "(Container will be recreated fresh on next launch)"

  # Phase 2: Auto-unbind GPU if it was bound for this VM
  if [[ "$gpu_mode" == "vm" ]]; then
    echo ""
    echo "GPU passthrough detected - restoring GPU to host..."

    if command -v omarchy-gpu-passthrough &>/dev/null; then
      # Verify GPU mode (marker may be stale after reboot)
      local actual_mode=""
      if command -v omarchy-gpu-passthrough-info &>/dev/null; then
        actual_mode=$(omarchy-gpu-passthrough-info mode 2>/dev/null)
      fi

      if [[ "$actual_mode" == "vm" ]]; then
        if omarchy-gpu-passthrough mode none 2>/dev/null; then
          echo "✅ GPU restored to mode=none (blacklisted)"
          notify_silent "Windows VM" "GPU restored to mode=none" "normal"
        else
          msg_warning "Warning: Failed to restore GPU"
          echo "   You can manually restore: omarchy-gpu-passthrough mode none"
          notify_silent "Windows VM" "Failed to restore GPU" "critical"
        fi
      else
        echo "ℹ️  GPU already restored (marker was stale, actual mode: ${actual_mode:-none})"
        # Clean up stale marker
        sudo rm -f /var/run/omarchy-vm-gpu-mode 2>/dev/null || true
      fi
    else
      msg_warning "Warning: GPU passthrough tools not found"
      echo "   GPU may still be bound to vfio-pci"
      echo "   Manual restore: omarchy-gpu-passthrough mode none"
    fi
    echo ""
  fi
}

show_compose() {
  # Check if docker-compose.yml exists
  if [[ ! -f "$COMPOSE_FILE" ]]; then
    msg_error "Windows VM not configured"
    echo "   Run: omarchy-windows-vm install"
    exit 1
  fi

  # Extract configuration from existing docker-compose.yml
  local SELECTED_RAM=$(grep 'RAM_SIZE:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
  local SELECTED_CORES=$(grep 'CPU_CORES:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
  local SELECTED_DISK=$(grep 'DISK_SIZE:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
  local USERNAME=$(grep 'USERNAME:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')
  local PASSWORD=$(grep 'PASSWORD:' "$COMPOSE_FILE" | awk '{print $2}' | tr -d '"')

  # Detect Looking Glass (check for kvmfr device)
  local LG_ENABLED=false
  if grep -q '/dev/kvmfr0' "$COMPOSE_FILE"; then
    LG_ENABLED=true
  fi

  # Detect GPU passthrough (check for vfio devices)
  local GPU_PASSTHROUGH_ENABLED=false
  local GPU_PCI_ADDR=""
  local GPU_AUDIO_PCI=""
  local GPU_IOMMU_GROUP=""

  if grep -q 'vfio-pci,host=' "$COMPOSE_FILE"; then
    GPU_PASSTHROUGH_ENABLED=true

    # Extract GPU addresses from ARGUMENTS
    GPU_PCI_ADDR=$(grep -oP 'vfio-pci,host=0000:\K[0-9a-f:.]+' "$COMPOSE_FILE" | head -1)
    GPU_AUDIO_PCI=$(grep -oP 'vfio-pci,host=0000:\K[0-9a-f:.]+' "$COMPOSE_FILE" | tail -1)

    # Extract IOMMU group from devices section
    GPU_IOMMU_GROUP=$(grep -oP '/dev/vfio/\K[0-9]+' "$COMPOSE_FILE" | head -1)
  fi

  # Detect IVSHMEM size (default 128)
  local IVSHMEM_SIZE=128
  if grep -q 'size=' "$COMPOSE_FILE"; then
    IVSHMEM_SIZE=$(grep -oP 'size=\K[0-9]+' "$COMPOSE_FILE" | head -1)
  fi

  # Generate docker-compose.yml to stdout
  create_docker_compose_config "-" "$SELECTED_RAM" "$SELECTED_CORES" "$SELECTED_DISK" \
    "$USERNAME" "$PASSWORD" "$LG_ENABLED" "$IVSHMEM_SIZE" \
    "$GPU_PASSTHROUGH_ENABLED" "$GPU_PCI_ADDR" "$GPU_AUDIO_PCI" "$GPU_IOMMU_GROUP"
}

status_windows() {
  check_vm_configured

  CONTAINER_STATUS=$(get_container_status)

  if [[ -z "$CONTAINER_STATUS" ]]; then
    echo "Windows VM container not found."
    echo "To start: omarchy-windows-vm launch"
  elif [[ "$CONTAINER_STATUS" == "running" ]]; then
    # Check if Looking Glass is available
    LG_STATUS=""
    if is_looking_glass_ready; then
      LG_STATUS="Looking Glass: Available"
    else
      LG_STATUS="Looking Glass: Not installed"
    fi

    gum style \
      --border normal \
      --padding "1 2" \
      --margin "1" \
      --align left \
      "Windows VM Status: RUNNING" \
      "" \
      "Web interface: http://127.0.0.1:8006" \
      "RDP available: port 3389" \
      "$LG_STATUS" \
      "" \
      "To connect (RDP):          omarchy-windows-vm launch" \
      "To connect (Looking Glass): omarchy-windows-vm launch --lg" \
      "To stop:                   omarchy-windows-vm stop"
  else
    echo "Windows VM is stopped (status: $CONTAINER_STATUS)"
    echo "To start: omarchy-windows-vm launch"
  fi
}

show_usage() {
  echo "Usage: omarchy-windows-vm [command] [options]"
  echo ""
  echo "Commands:"
  echo "  install              Install and configure Windows VM"
  echo "  remove               Remove Windows VM and optionally its data"
  echo "  launch [options]     Start Windows VM (if needed) and connect (RDP default, --lg for Looking Glass)"
  echo "                       Options:"
  echo "                         --keep-alive, -k        Keep VM running after RDP closes"
  echo "                         --looking-glass, --lg   Connect via Looking Glass"
  echo "  stop                 Stop the running Windows VM"
  echo "  status               Show current VM status"
  echo "  show-compose         Display generated docker-compose.yml configuration (for testing/debugging)"
  echo "  help                 Show this help message"
  echo ""
  echo "Examples:"
  echo "  omarchy-windows-vm install           # Set up Windows VM for first time"
  echo "  omarchy-windows-vm launch            # Connect to VM (auto-stop on exit)"
  echo "  omarchy-windows-vm launch -k         # Connect to VM (keep running)"
  echo "  omarchy-windows-vm show-compose      # View generated config without creating file"
  echo "  omarchy-windows-vm stop              # Shut down the VM"
}

# Main command dispatcher
case "$1" in
install)
  install_windows
  ;;
remove)
  remove_windows
  ;;
launch | start)
  shift # Remove the command name from arguments
  launch_windows "$@"
  ;;
stop | down)
  stop_windows
  ;;
status)
  status_windows
  ;;
show-compose)
  show_compose
  ;;
help | --help | -h | "")
  show_usage
  ;;
*)
  echo "Unknown command: $1" >&2
  echo "" >&2
  show_usage >&2
  exit 1
  ;;
esac
